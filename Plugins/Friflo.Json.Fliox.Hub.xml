<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Friflo.Json.Fliox.Hub</name>
    </assembly>
    <members>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EntityUtils`2">
            <summary>
            Utility methods for type safe key conversion and generic <typeparamref name="TKey"/> access for entities of type <typeparamref name="T"/>.
            </summary>
            <remarks>
            Use <see cref="P:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Utils"/> for more convenience.
            The Utils property provide the same feature set without passing generic types <typeparamref name="TKey"/> and <typeparamref name="T"/>.  
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.SetUtils`2">
            <summary>
            Utility methods for type safe key conversion and generic <typeparamref name="TKey"/> access for entities of type <typeparamref name="T"/>.
            </summary>
            <remarks>
            Same feature set as <see cref="T:Friflo.Json.Fliox.Hub.Client.EntityUtils`2"/> but more convenient.
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EventTargets">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Client.EventTargets"/> instructs the Hub to forward messages as events only to the specified targets.
            Event target's can be specified its <b>users, clients or groups</b>.
            </summary>
            <remarks>
            In case no targets are specified - the default - a message is sent to all clients subscribing the message.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventTargetsExtension.EventTargetUser``1(``0,System.String)">
            <summary> Send the <paramref name="message"/> as an event only to the given <paramref name="user"/> </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.EventTargets"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventTargetsExtension.EventTargetUser``1(``0,Friflo.Json.Fliox.ShortString@)">
            <summary> Send the <paramref name="message"/> as an event only to the given <paramref name="user"/> </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.EventTargets"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventTargetsExtension.EventTargetUsers``1(``0,System.Collections.Generic.ICollection{System.String})">
            <summary> Send the <paramref name="message"/> as an event only to the given <paramref name="users"/> </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.EventTargets"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventTargetsExtension.EventTargetUsers``1(``0,System.Collections.Generic.ICollection{Friflo.Json.Fliox.ShortString})">
            <summary> Send the <paramref name="message"/> as an event only to the given <paramref name="users"/> </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.EventTargets"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventTargetsExtension.EventTargetClient``1(``0,System.String)">
            <summary> Send the <paramref name="message"/> as an event only to the given <paramref name="client"/> </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.EventTargets"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventTargetsExtension.EventTargetClient``1(``0,Friflo.Json.Fliox.ShortString@)">
            <summary> Send the <paramref name="message"/> as an event only to the given <paramref name="client"/> </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.EventTargets"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventTargetsExtension.EventTargetClients``1(``0,System.Collections.Generic.ICollection{System.String})">
            <summary> Send the <paramref name="message"/> as an event only to the given <paramref name="clients"/> </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.EventTargets"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventTargetsExtension.EventTargetClients``1(``0,System.Collections.Generic.ICollection{Friflo.Json.Fliox.ShortString})">
            <summary> Send the <paramref name="message"/> as an event only to the given <paramref name="clients"/> </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.EventTargets"/>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.TaskNotSyncedException">
            <summary>
            Is throw when accessing the <b>Result</b> of an un-synced task. 
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.TaskAlreadySyncedException">
            <summary>
            Is thrown if calling a method on a task which was already executed by <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.TaskResultException">
            <summary>
            Is thrown when accessing the <b>Result</b> of a synced task which returned an <see cref="P:Friflo.Json.Fliox.Hub.Client.SyncTask.Error"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.SyncTasksException">
            <summary>
            Is thrown in case invocation of <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> failed entirely. E.g. a connection issue. 
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.FlioxClient">
            <summary>
            Application classes extending <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> offer two main functionalities: <br/>
            <b>1.</b> Define a <b>database schema</b> by declaring its containers, commands and messages <br/>
            <b>2.</b> Its instances are <b>database clients</b> providing type-safe access to database containers, commands and messages
            </summary>
            <remarks>
            Its containers are fields or properties of type <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>.<br/>
            Its commands are methods returning a <see cref="T:Friflo.Json.Fliox.Hub.Client.CommandTask`1"/>.<br/>
            Its messages are methods returning a <see cref="T:Friflo.Json.Fliox.Hub.Client.MessageTask"/>.<br/>
            <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> instances can be used in server and client code.<br/>
            The <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> features and utilization available at
            <a href="https://github.com/friflo/Friflo.Json.Fliox/blob/main/Json/Fliox.Hub/Client/README.md">Client README.md</a><br/>
            <br/>
            <b>Info</b>:
            A single <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> instance support multiple parallel async operations executed with <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/>.<br/>
            E.g. multiple <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> can be called without immediate await and instead using <c>Task.WhenAll()</c> for all tasks. 
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks">
            <summary> Execute all tasks created by methods of <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> and <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> </summary>
            <remarks>
            In case any task failed a <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncTasksException"/> is thrown. <br/>
            As an alternative use <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.TrySyncTasks"/> to execute tasks which does not throw an exception. <br/>
            The method can be called without awaiting the result of a previous call. </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.TrySyncTasks">
            <summary> Execute all tasks created by methods of <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> and <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> </summary>
            <remarks>
            Failed tasks are available via the returned <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncResult"/> in the field <see cref="F:Friflo.Json.Fliox.Hub.Client.SyncResult.failed"/> <br/>
            In performance critical application this method should be used instead of <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> as throwing exceptions is expensive. <br/> 
            The method can be called without awaiting the result of a previous call. </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.TrySyncAcknowledgeEvents">
            <summary> Specific characteristic: Method can run in parallel on any thread </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.CancelPendingSyncs">
            <summary> Cancel execution of pending calls to <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> and <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.TrySyncTasks"/> </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasksSynchronous">
            <summary> Execute all tasks created by methods of <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> and <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> </summary>
            <remarks>
            In case any task failed a <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncTasksException"/> is thrown. <br/>
            As an alternative use <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.TrySyncTasks"/> to execute tasks which does not throw an exception. <br/>
            The method can be called without awaiting the result of a previous call. </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.TrySyncTasksSynchronous">
            <summary> Execute all tasks created by methods of <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> and <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> </summary>
            <remarks>
            Failed tasks are available via the returned <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncResult"/> in the field <see cref="F:Friflo.Json.Fliox.Hub.Client.SyncResult.failed"/> <br/>
            In performance critical application this method should be used instead of <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> as throwing exceptions is expensive. <br/> 
            The method can be called without awaiting the result of a previous call. </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.ProcessEvents(Friflo.Json.Fliox.JsonValue@)">
            <summary>
            Process the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.EventMessage.events"/> of the passed serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/>
            </summary>
            <remarks>
            This method is not reentrant.
            The calling <see cref="T:Friflo.Json.Fliox.Hub.Client.EventProcessor"/> ensures this method is called sequentially.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.AcknowledgeEvents(System.Object)">
            <summary> Specific characteristic: Method can run in parallel on any thread </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.CreateMemoryBuffer">
            <summary>
            By default a new <see cref="T:Friflo.Json.Fliox.Utils.MemoryBuffer"/> is created as its array may be used by the application
            at any time later. <br/>
            It returns a pooled <see cref="T:Friflo.Json.Fliox.Utils.MemoryBuffer"/> only if the application calls <see cref="M:Friflo.Json.Fliox.Hub.Client.SyncResult.Reuse(Friflo.Json.Fliox.Hub.Client.FlioxClient)"/>
            indicating its safe to do so.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.CreateSyncRequest(Friflo.Json.Fliox.Hub.Client.Internal.SyncStore@,Friflo.Json.Fliox.Mapper.ObjectMapper)">
            <summary>
            Returning current <see cref="F:Friflo.Json.Fliox.Hub.Client.Internal.ClientIntern.syncStore"/> as <paramref name="syncStore"/> enables request handling
            in a worker thread while calling <see cref="T:Friflo.Json.Fliox.Hub.Client.Internal.SyncStore"/> methods from 'main' thread.
            
            <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.eventAck"/> is set to acknowledge already received events to clear
            <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.sentEventMessages"/>. This avoids resending already received events on reconnect. 
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.Tasks">
            <summary> List of tasks created by its <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> methods. These tasks are executed when calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.DatabaseName">
            <summary> name of the database the client is attached to </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.std">
            <summary> access to standard database commands - <see cref="T:Friflo.Json.Fliox.Hub.Client.StdCommands"/> </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.ClientInfo">
            <summary> general client information: attached database, the number of cached entities and scheduled <see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.Tasks"/> </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.GetSyncCount">
            <summary> Return the number of calls to <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> and <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.TrySyncTasks"/> </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.GetPendingSyncCount">
            <summary> Return the number of pending <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> and <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.TrySyncTasks"/> calls </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.FlioxClient.send">
            <summary> Used to send typed messages / commands by classes extending <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/></summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.UserId">
            <summary>user id - identifies the user at a Hub</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.Token">
            <summary><see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.Token"/> - used to authenticate the <see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.UserId"/> at the Hub</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.ClientId">
            <summary>client id - identifies the client at a Hub</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.UserInfo">
            <summary>The tuple of <see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.UserId"/>, <see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.Token"/> and <see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.ClientId"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.FlioxClient.Static">
            <summary> using a static class prevents noise in form of 'Static members' for class instances in Debugger </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.FlioxClient.Static.OriginalContext">
            <summary>
            Process continuation of <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.ExecuteAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext,Friflo.Json.Fliox.Hub.Host.ExecutionType)"/> on caller context. <br/>
            This ensures modifications to entities are applied on the same context used by the caller. <br/>
            It also ensures that <see cref="F:Friflo.Json.Fliox.Hub.Client.SyncTask.OnSync"/> is called on caller context. <br/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.#ctor(Friflo.Json.Fliox.Hub.Host.FlioxHub,System.String)">
            <summary>
            Instantiate a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> for the <paramref name="dbName"/> exposed by the given <paramref name="hub"/>.
            If <paramref name="dbName"/> is null the client uses the default database assigned to the <paramref name="hub"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.Reset">
            <summary> Remove all tasks and all tracked entities of the <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.DetectAllPatches">
            <summary>
            Detect the <b>Patches</b> made to all tracked entities in all <b>EntitySet</b>s of the client.
            Detected patches are applied to the database containers when calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/>.        
            </summary>
            <remarks>
            Consider using one of the <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DetectPatches"/> methods as this method
            run detection on all tracked entities in all <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>s.
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscriptionEventHandler">
            <summary>
            <see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscriptionEventHandler"/> is called for all subscription events received by the <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SetEventProcessor(Friflo.Json.Fliox.Hub.Client.EventProcessor)">
            <summary>
            Set the <see cref="T:Friflo.Json.Fliox.Hub.Client.EventProcessor"/> used to process subscription events subscribed by a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/><br/>
            </summary>
            <remarks>
            By default a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> uses a <see cref="T:Friflo.Json.Fliox.Hub.Client.SynchronousEventProcessor"/> to handle subscription events
            in the thread an event arrives.<br/>
            In case of an <b>UI</b> application an <see cref="T:Friflo.Json.Fliox.Hub.Client.EventProcessorContext"/> can be used to process
            subscription events on the <b>UI</b> thread by using the <see cref="T:System.Threading.SynchronizationContext"/>
            of the application.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeAllChanges(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler)">
            <summary>
            Subscribe to database changes of all <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/>'s with the given <paramref name="change"/>.
            To unsubscribe from receiving change events set <paramref name="change"/> to <see cref="F:Friflo.Json.Fliox.Hub.Client.Change.None"/>.
            </summary>
            <remarks>Note: To ensure remote clients with occasional disconnects get <b>all</b> events use <see cref="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Client(Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam)"/></remarks>
            <seealso cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SetEventProcessor(Friflo.Json.Fliox.Hub.Client.EventProcessor)"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage``1(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler{``0})">
            <summary> Subscribe message / command with the given <paramref name="name"/> send to the database used by the client </summary>
            <remarks>Note: To ensure remote clients with occasional disconnects get <b>all</b> events use <see cref="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Client(Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam)"/></remarks>
            <seealso cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SetEventProcessor(Friflo.Json.Fliox.Hub.Client.EventProcessor)"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)">
            <summary> Subscribe message / command with the given <paramref name="name"/> send to the database used by the client </summary>
            <remarks>
            Subscribe multiple messages by prefix. e.g. <paramref name="name"/> = <c>"std.*"</c> <br/>
            Subscribe all messages with <paramref name="name"/> = <c>"*"</c> <br/>
            </remarks>
            <remarks>Note: To ensure remote clients with occasional disconnects get <b>all</b> events use <see cref="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Client(Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam)"/></remarks>
            <seealso cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SetEventProcessor(Friflo.Json.Fliox.Hub.Client.EventProcessor)"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.UnsubscribeMessage``1(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler{``0})">
            <summary> Remove subscription of message / command with the given <paramref name="name"/> send to the database used by the client </summary>
            <remarks> If <paramref name="handler"/> is null all subscription handlers are removed. </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.UnsubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)">
            <summary> Remove subscription of message / command with the given <paramref name="name"/> send to the database used by the client </summary>
            <remarks>
            If <paramref name="handler"/> is null all subscription handlers are removed. <br/>
            Remove a prefix subscription with a trailing <c>*</c> E.g: <paramref name="name"/> = <c>"std.*"</c> or <c>"*"</c> <br/>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendTask.Message``1(``0,System.String)">
            <summary>
            Send a message with the name of the calling method and <paramref name="param"/> value to a database.<br/>
            Other clients can subscribe the message to receive an event with <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendTask.Command``1(System.String)">
            <summary>
            Send a command with the name of the calling method (without a command value) to a database.<br/>
            Other clients can subscribe the command to receive an event with <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendTask.Command``2(``0,System.String)">
            <summary>
            Send a command with the name of the calling method and <paramref name="param"/> value to a database.<br/>
            Other clients can subscribe the command to receive an event with <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendMessage(System.String)">
            <summary>
            Send a message with the given <paramref name="name"/> (without a value) to a database.
            Other clients can subscribe the message to receive an event with <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>.
            </summary>
            <remarks>
            The method can be used directly for rapid prototyping. <br/>For production grade code encapsulate call by adding a message method to
            the <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> subclass. This adds the message and its API to the <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/>. 
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendMessage``1(System.String,``0)">
            <summary>
            Send a message with the given <paramref name="name"/> and <paramref name="param"/> value to a database.
            Other clients can subscribe the message to receive an event with <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>.
            </summary>
            <remarks>
            The method can be used directly for rapid prototyping. <br/> For production grade code encapsulate call by adding a message method to
            the <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> subclass. Doing this adds the message and its signature to the <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/>. 
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendCommand``1(System.String)">
            <summary>
            Send a command with the given <paramref name="name"/> (without a command value) to a database.
            Other clients can subscribe the command to receive an event with <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>.
            </summary>
            <remarks>
            The method can be used directly for rapid prototyping. <br/> For production grade code encapsulate call by adding a message method to
            the <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> subclass. This adds the command and its API to the <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/>. 
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendCommand``2(System.String,``0)">
            <summary>
            Send a command with the given <paramref name="name"/> and <paramref name="param"/> value to a database.
            Other clients can subscribe the command to receive an event with <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>.
            </summary>
            <remarks>
            The method can be used directly for rapid prototyping. <br/> For production grade code encapsulate call by adding a message method to
            the <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> subclass. Doing this adds the command and its signature to the <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/>. 
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.GetEntityTypes(System.Type)">
            <summary>
            Return the <see cref="T:System.Type"/>'s used by the <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> members of a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> as entity Type. 
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.GetEntitySetInfos(Friflo.Json.Fliox.Hub.Client.FlioxClient)">
            <summary>
            Enable creation of strongly typed<see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>'s
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.LocalEntities`2">
            <summary>
            Provide access to entities tracked by an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>.
            </summary>
            <remarks>
            An entity become tracked if the <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> gets aware of an entity by following calls  
            <list type="bullet">
              <item>.Create(), .CreateRange(), .Upsert(), .UpsertRange()</item>
              <item>.Read().Find() or .FindRange()</item>
              <item>.Query(), .QueryAll(), .QueryByFilter()</item>
            </list>
            <see cref="T:Friflo.Json.Fliox.Hub.Client.LocalEntities`2"/> adapts the behavior of <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>
            </remarks>
            <typeparam name="TKey">Entity key type</typeparam>
            <typeparam name="T">Entity type</typeparam>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.LocalEntities`2.Count">
            <summary> return number of tracked entities </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.LocalEntities`2.Keys">
            <summary> Return the keys of all tracked entities in the <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.LocalEntities`2.Entities">
            <summary> Return all tracked entities in the <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.LocalEntities`2.ContainsKey(`0)">
            <summary>
            Return true if the <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> contains an entity with the passed <paramref name="key"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.LocalEntities`2.TryGetEntity(`0,`1@)">
            <summary>
            Get the <paramref name="entity"/> with the passed <paramref name="key"/> from the <see cref="T:Friflo.Json.Fliox.Hub.Client.Internal.Set"/>.
            Return true if the <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> contains an entity with the given key. Otherwise false.
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.LocalEntities`2.Item(`0)">
            <summary>
            Gets the tracked entity associated with the specified <paramref name="key"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.LocalEntities`2.GetEnumerator">
            <summary> Returns an enumerator that iterates through the <see cref="T:Friflo.Json.Fliox.Hub.Client.LocalEntities`2"/> </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.NamespaceDoc">
            <summary>
            Types utilized by <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> and its <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> members
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EntityPatchInfo">
            <summary>
            Contain the <see cref="F:Friflo.Json.Fliox.Hub.Client.EntityPatchInfo.merge"/> patch applied to an entity identified by its <see cref="F:Friflo.Json.Fliox.Hub.Client.EntityPatchInfo.id"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EntityPatchInfo`2">
            <summary>
            Contain the <see cref="P:Friflo.Json.Fliox.Hub.Client.EntityPatchInfo`2.Merge"/> patch patches applied to an <see cref="P:Friflo.Json.Fliox.Hub.Client.EntityPatchInfo`2.Entity"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.SetInfo">
            <summary>
            Contain the number of tracked entities of an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> and the number of tasks grouped by type.
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.SetInfo.Name">
            <summary>container name / <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.peers">
            <summary>number of tracked entities in an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.tasks">
            <summary>current number of tasks <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> scheduled by an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.create">
            <summary>number of create tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.upsert">
            <summary>number of upsert tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.read">
            <summary>number of read tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.query">
            <summary>number of query tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.aggregate">
            <summary>number of aggregate tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.closeCursors">
            <summary>number of close query cursor tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.subscribeChanges">
            <summary>number of container subscription tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.merge">
            <summary>number of patch tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SetInfo.delete">
            <summary>number of delete tasks</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.SyncResult">
            <summary>
            Contains the result of <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> / <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.TrySyncTasks"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.SyncTask">
            <summary>
            Base class of all tasks create via methods of <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> and <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SyncTask.OnSync">
            <summary>
            A handler method assigned to <see cref="F:Friflo.Json.Fliox.Hub.Client.SyncTask.OnSync"/> is called after executing a <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncTask"/> with
            <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/>. <br/>
            This is an alternative way to process a <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncTask"/> result to the common task processing shown below.
            </summary>
            <remarks>
            It is intended to be used in scenarios where a set of tasks are not created in a single function block
            like in the example below. <br/>
            This is typical for game applications where <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> is called by the game loop
            for every frame to batch multiple <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncTask"/>'s created on various places. <br/>
            <code>
            // Common task processing
            var articles = client.articles.QueryAll();
            var orders   = client.orders.QueryAll();
            await client.SyncTasks(); 
            foreach (var article in articles) { ... }
            foreach (var order in orders) { ... }
            </code>
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.SyncTask.Success">
            <summary>
            Is true in case task execution was successful. Otherwise false. If false <see cref="P:Friflo.Json.Fliox.Hub.Client.SyncTask.Error"/> property is set. 
            </summary>
            <exception cref="T:Friflo.Json.Fliox.Hub.Client.TaskNotSyncedException"></exception>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.SyncTask.Error">
            <summary>The error caused the task failing. Return null if task was successful - <see cref="P:Friflo.Json.Fliox.Hub.Client.SyncTask.Success"/> == true</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.SyncTaskExtension.TaskName``1(``0,System.String)">
            <summary>
            An arbitrary name which can be assigned to a task. Typically the name of the variable the task is assigned to.
            The <paramref name="name"/> is used to simplify finding a <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncTask"/> in the source code while debugging.
            It also simplifies finding a <see cref="T:Friflo.Json.Fliox.Hub.Client.TaskError"/> by its <see cref="P:Friflo.Json.Fliox.Hub.Client.TaskError.Message"/>
            or a <see cref="T:Friflo.Json.Fliox.Hub.Client.TaskResultException"/> by its <see cref="P:System.Exception.Message"/>.
            The library itself doesn't use the <paramref name="name"/> internally - its purpose is only to enhance debugging
            or post-mortem debugging of application code.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.TaskError">
            <summary>
            Contains the <see cref="F:Friflo.Json.Fliox.Hub.Client.TaskError.type"/> and the error <see cref="P:Friflo.Json.Fliox.Hub.Client.TaskError.Message"/> of task in case its execution failed.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.TaskError.entityErrors">
            The entities caused that task failed. Return empty dictionary in case of no entity errors. Is never null.
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.TaskError.taskMessage">
            Return a single line error message. Is never null.
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.TaskError.stacktrace">
            Return the stacktrace for an <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.UnhandledException"/> if provided. Otherwise null.
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.TaskError.Message">
            Note: Does contain an exception <see cref="F:Friflo.Json.Fliox.Hub.Client.TaskError.stacktrace"/> in case the used <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> provide a stacktrace.
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.TaskError.GetMessage(System.Boolean)">
            Note: The library itself set <param name="showStack"/> to true only when called from <see cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.DisposeUtils">
            <summary>
            Set of utility methods to guide a graceful shutdown by disposing all resources.
            </summary>
            <remarks>
            The intended order for shutdown is:
            <list type="bullet">
                <item><see cref="M:Friflo.Json.Fliox.Hub.Client.DisposeUtils.DisposeStore(Friflo.Json.Fliox.Hub.Client.FlioxClient)"/></item>
                <item><see cref="M:Friflo.Json.Fliox.Hub.Client.DisposeUtils.DisposeDatabase(Friflo.Json.Fliox.Hub.Host.FlioxHub)"/></item>
                <item><see cref="M:Friflo.Json.Fliox.Hub.Client.DisposeUtils.DisposeCaches"/></item>
            </list>
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2">
            <summary>
            An EntitySet represents a collection (table) of entities (records) of type <typeparamref name="T"/> and their key type <typeparamref name="TKey"/>. <br/>
            The methods of an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> enable to create, read, upsert, delete, patch and aggregate container entities.<br/>
            It also allows to subscribe to entity changes made by other database clients.
            </summary>
            <remarks>
            <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>'s are designed to be used as fields or properties inside a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>. <br/>
            The type <typeparamref name="T"/> of a container entity need to be a class containing a field or property used as its <b>key</b> - the primary key. <br/>
            This key field is usually named <b>id</b>. Using a different name for the primary key requires the field annotation <b>[Key]</b>.<br/>
            Supported <typeparamref name="TKey"/> types are:
            <see cref="T:System.String"/>, <see cref="T:System.Int64"/>, <see cref="T:System.Int32"/>, <see cref="T:System.Int16"/>, <see cref="T:System.Byte"/> and <see cref="T:System.Guid"/>.
            The type of <typeparamref name="TKey"/> must match the <see cref="T:System.Type"/> used for the <b>[Key]</b> field / property in an entity class.
            In case of a type mismatch a runtime exceptions is thrown.
            </remarks>
            <typeparam name="TKey">Entity key type</typeparam>
            <typeparam name="T">Entity type</typeparam>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EntitySet`2.WritePretty">
            <summary> If true the serialization of entities to JSON is prettified </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EntitySet`2.WriteNull">
            <summary> If true the serialization of entities to JSON write null fields. Otherwise null fields are omitted </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Utils">
            <summary>
            Utility methods for type safe key conversion and generic <typeparamref name="TKey"/> access for entities of type <typeparamref name="T"/>
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Tasks">
            <summary> List of tasks created by its <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> methods. These tasks are executed when calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Local">
            <summary> Provide access to the <see cref="T:Friflo.Json.Fliox.Hub.Client.LocalEntities`2"/> tracked by the <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Static">
            <summary> using a static class prevents noise in form of 'Static members' for class instances in Debugger </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.#ctor(Friflo.Json.Fliox.Hub.Client.FlioxClient,System.Int32)">
            constructor is called via <see cref="M:Friflo.Json.Fliox.Hub.Client.Internal.Map.GenericContainerMember`2.SetContainerMember(Friflo.Json.Fliox.Hub.Client.FlioxClient,System.Int32)"/> 
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.#ctor(Friflo.Json.Fliox.Hub.Client.FlioxClient,Friflo.Json.Fliox.Hub.Client.Internal.Map.EntitySetInfo)">
            <summary>
            Create an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> for the given client.<br/>
            The <see cref="T:Friflo.Json.Fliox.Hub.Client.Internal.Map.EntitySetInfo"/> can be retrieved from <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.GetEntitySetInfos(Friflo.Json.Fliox.Hub.Client.FlioxClient)"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Read">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.ReadTask`2"/> used to read entities <b>by id</b> added with <see cref="M:Friflo.Json.Fliox.Hub.Client.ReadTask`2.Find(`0)"/> subsequently
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Find(`0)">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.FindTask`2"/> used to read a single entity.
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Query(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.QueryTask`2"/> with the given LINQ query <paramref name="filter"/>
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.QueryByFilter(Friflo.Json.Fliox.Hub.Client.EntityFilter{`1})">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.QueryTask`2"/> with the given <see cref="T:Friflo.Json.Fliox.Hub.Client.EntityFilter`1"/>
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.QueryAll">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.QueryTask`2"/> to query all entities of an container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.CloseCursors(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Close the <paramref name="cursors"/> returned by <see cref="P:Friflo.Json.Fliox.Hub.Client.QueryTask`2.ResultCursor"/> of a <see cref="T:Friflo.Json.Fliox.Hub.Client.QueryTask`2"/>
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Count(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.CountTask`1"/> counting all entities matching to the given LINQ query <paramref name="filter"/>
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.CountByFilter(Friflo.Json.Fliox.Hub.Client.EntityFilter{`1})">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.CountTask`1"/> counting all entities matching to the given  <see cref="T:Friflo.Json.Fliox.Hub.Client.EntityFilter`1"/>
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.CountAll">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.CountTask`1"/> counting all entities in a container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChangesFilter(Friflo.Json.Fliox.Hub.Client.Change,System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})">
            <summary>
            Subscribe to database changes of the related <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> with the given <paramref name="change"/>.<br/>
            To unsubscribe from receiving change events set <paramref name="change"/> to <see cref="F:Friflo.Json.Fliox.Hub.Client.Change.None"/>.<br/>
            </summary>
            <remarks>
            To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> <br/>
            The <see cref="T:Friflo.Json.Fliox.Hub.Client.Changes`2"/> of a subscription event can be applied to an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>
            with <see cref="M:Friflo.Json.Fliox.Hub.Client.Changes`2.ApplyChangesTo(Friflo.Json.Fliox.Hub.Client.EntitySet{`0,`1},Friflo.Json.Fliox.Hub.Client.Change)"/>.
            <br/>
            <b>Note:</b> In case using the same <paramref name="filter"/> in multiple queries use <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChangesByFilter(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.EntityFilter{`1},Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})"/>
            to avoid the overhead to convert the <paramref name="filter"/> expression.
            <br/>
            <b>Note:</b> To ensure remote clients with occasional disconnects get <b>all</b> events set
            <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam.queueEvents"/> in <see cref="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Client(Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam)"/> to true. 
            </remarks>
            <seealso cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SetEventProcessor(Friflo.Json.Fliox.Hub.Client.EventProcessor)"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChangesByFilter(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.EntityFilter{`1},Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})">
            <summary>
            Subscribe to database changes of the related <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> with the given <paramref name="change"/>. <br/>
            To unsubscribe from receiving change events set <paramref name="change"/> to <see cref="F:Friflo.Json.Fliox.Hub.Client.Change.None"/>. <br/>
            </summary>
            <remarks>
            To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> <br/>
            The <see cref="T:Friflo.Json.Fliox.Hub.Client.Changes`2"/> of a subscription event can be applied to an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>
            with <see cref="M:Friflo.Json.Fliox.Hub.Client.Changes`2.ApplyChangesTo(Friflo.Json.Fliox.Hub.Client.EntitySet{`0,`1},Friflo.Json.Fliox.Hub.Client.Change)"/>. <br/>
            <b>Note:</b> In case using the same <paramref name="filter"/> in multiple queries use <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChangesByFilter(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.EntityFilter{`1},Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})"/>
            to avoid the overhead to convert the <paramref name="filter"/> expression.
            </remarks> 
            <seealso cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SetEventProcessor(Friflo.Json.Fliox.Hub.Client.EventProcessor)"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChanges(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})">
            <summary>
            Subscribe to database changes of the related <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> with the given <paramref name="change"/>.
            To unsubscribe from receiving change events set <paramref name="change"/> to <see cref="F:Friflo.Json.Fliox.Hub.Client.Change.None"/>.
            </summary>
            <remarks> The <see cref="T:Friflo.Json.Fliox.Hub.Client.Changes`2"/> of a subscription event can be applied to an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>
            with <see cref="M:Friflo.Json.Fliox.Hub.Client.Changes`2.ApplyChangesTo(Friflo.Json.Fliox.Hub.Client.EntitySet{`0,`1},Friflo.Json.Fliox.Hub.Client.Change)"/>. <br/>
            To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> <br/></remarks>
            <remarks><br/>Note: To ensure remote clients with occasional disconnects get <b>all</b> events use <see cref="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Client(Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam)"/></remarks>
            <seealso cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SetEventProcessor(Friflo.Json.Fliox.Hub.Client.EventProcessor)"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Create(`1)">
            <summary>
            Return a <see cref="T:Friflo.Json.Fliox.Hub.Client.CreateTask`1"/> used to create the given <paramref name="entity"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.CreateRange(System.Collections.Generic.List{`1})">
            <summary>
            Return a <see cref="T:Friflo.Json.Fliox.Hub.Client.CreateTask`1"/> used to to create the given <paramref name="entities"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.CreateRange(System.Collections.Generic.ICollection{`1})">
            <summary>
            Return a <see cref="T:Friflo.Json.Fliox.Hub.Client.CreateTask`1"/> used to to create the given <paramref name="entities"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Upsert(`1)">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.UpsertTask`1"/> used to upsert the given <paramref name="entity"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.UpsertRange(System.Collections.Generic.List{`1})">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.UpsertTask`1"/> used to upsert the given <paramref name="entities"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.UpsertRange(System.Collections.Generic.ICollection{`1})">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.UpsertTask`1"/> used to upsert the given <paramref name="entities"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Delete(`1)">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.DeleteTask`2"/> to delete the given <paramref name="entity"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.Delete(`0)">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.DeleteTask`2"/> to delete the entity with the passed <paramref name="key"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DeleteRange(System.Collections.Generic.ICollection{`1})">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.DeleteTask`2"/> to delete the given <paramref name="entities"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DeleteRange(System.Collections.Generic.List{`0})">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.DeleteTask`2"/> to delete the entities with the passed <paramref name="keys"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DeleteRange(System.Collections.Generic.ICollection{`0})">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.DeleteTask`2"/> to delete the entities with the passed <paramref name="keys"/> in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DeleteAll">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Client.DeleteAllTask`2"/> to delete all entities in the container
            </summary>
            <remarks> To execute the task call <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DetectPatches">
            <summary>
            Detect <see cref="P:Friflo.Json.Fliox.Hub.Client.DetectPatchesTask`2.Patches"/> made to all tracked entities.
            Detected patches are applied to the container when calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/>
            </summary>
            <remarks> Consider using <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DetectPatches(`1)"/> or <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DetectPatches(System.Collections.Generic.IEnumerable{`1})"/>
            as this method run detection on all tracked entities. </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DetectPatches(`1)">
            <summary>
            Detect <see cref="P:Friflo.Json.Fliox.Hub.Client.DetectPatchesTask`2.Patches"/> made to the passed tracked <paramref name="entity"/>.
            Detected patches are applied to the container when calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.DetectPatches(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Detect <see cref="P:Friflo.Json.Fliox.Hub.Client.DetectPatchesTask`2.Patches"/> made to the passed tracked <paramref name="entities"/>.
            Detected patches are applied to the container when calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler">
            <summary>
            Defines signature of the handler method passed to <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeAllChanges(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler)"/>
            </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.SubscriptionEventHandler"/>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler`2">
            <summary>
            Defines signature of the handler method passed to <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChanges(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})"/>
            </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.SubscriptionEventHandler"/>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.Changes">
            <summary>
            Contain <b>raw</b> changes (mutations) made to a container subscribed with <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChanges(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})"/>.
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Changes.Count">
            <summary> total number of container changes </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Changes.ChangeInfo">
            <summary> number of changes per mutation type: creates, upserts, deletes and patches </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Changes.Container">
            <summary> name of the container the changes are referring to </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.Changes`2">
            <summary>
            Contain <b>strongly typed</b> changes (mutations) made to a container subscribed with <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChanges(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})"/>.
            </summary>
            <remarks>
            Following properties provide type-safe access to the different types of container changes 
            <list type="bullet">
              <item> <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Creates"/> - the created container entities</item>
              <item> <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Upserts"/> - the upserted container entities</item>
              <item> <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Deletes"/> - the keys of removed container entities</item>
              <item> <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Patches"/> - the patches applied to container entities</item>
            </list>
            Container <see cref="T:Friflo.Json.Fliox.Hub.Client.Changes`2"/> are not automatically applied to an <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>.
            To apply container changes to a <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> call <see cref="M:Friflo.Json.Fliox.Hub.Client.Changes`2.ApplyChangesTo(Friflo.Json.Fliox.Hub.Client.EntitySet{`0,`1},Friflo.Json.Fliox.Hub.Client.Change)"/>.
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Creates">
            <summary> return the entities created in a container </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Upserts">
            <summary> return the entities upserted in a container </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Deletes">
            <summary> return the keys of removed container entities </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Patches">
            <summary> return patches applied to container entities </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Changes`2.#ctor(Friflo.Json.Fliox.Hub.Client.Internal.Set{`0,`1},Friflo.Json.Fliox.Hub.Client.SubscriptionIntern)">
            <summary> called via <see cref="M:Friflo.Json.Fliox.Hub.Client.SubscriptionProcessor.GetChanges(Friflo.Json.Fliox.Hub.Client.Internal.Set)"/> </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Changes`2.GetKeys(System.Collections.Generic.ICollection{`0})">
            <summary>
            add the keys of all <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Creates"/>, <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Upserts"/>, <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Deletes"/> and <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Patches"/>
            to the passed <paramref name="keys"/> collection. 
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Changes`2.ApplyChangesTo(Friflo.Json.Fliox.Hub.Client.EntitySet{`0,`1},Friflo.Json.Fliox.Hub.Client.Change)">
            <summary> Apply the container changes to the given <paramref name="entitySet"/> </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.SubscriptionEventHandler">
            <summary>
            Defines the signature of the event handler passed to <see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscriptionEventHandler"/> <br/>
            </summary>
            <remarks>
            All subscription handler methods are synchronous by intention.<br/>
            <b>Reason:</b>
            In contrast to handler methods of a service or a web server subscription handlers don't return a result. <br/>
            In case the application need to call an asynchronous method consider using the approach below:
            <code>
                Task.Factory.StartNew(() => AsyncMethod());
            </code>
            <b>Note:</b> exceptions thrown in the <c>AsyncMethod()</c> are unhandled. Add try/catch to log exceptions.
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EventContext">
            <summary>
            The <see cref="T:Friflo.Json.Fliox.Hub.Client.EventContext"/> provide all information of subscription events received by a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>.<br/>
            </summary>
            <remarks>
            Subscription events are received by a client in case the client setup subscriptions by the <b>Subscribe*()</b> methods
            of <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> or <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>.<br/>
            The event context provide the following event data.
            <list type="bullet">
              <item> The <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.UserId"/> - the origin of the event</item>
              <item> The <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.Messages"/> send by a user </item>
              <item> The container <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.Changes"/> made by a user. <br/>
              Use <see cref="M:Friflo.Json.Fliox.Hub.Client.EventContext.GetChanges``2(Friflo.Json.Fliox.Hub.Client.EntitySet{``0,``1})"/> to get typed container changes.
              </item>
              <item> The <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.EventInfo"/> containing the number of messages and database changes </item>
            </list>
            Database change events are not automatically applied to a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>.<br/>
            To apply database change events to a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> call <see cref="M:Friflo.Json.Fliox.Hub.Client.EventContext.ApplyChangesTo(Friflo.Json.Fliox.Hub.Client.FlioxClient)"/>.
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EventContext.UserId">
            <summary> user id sending the <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.Messages"/> and causing the <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.Changes"/>  </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EventContext.EventSeq">
            <summary> incrementing sequence number of a received event </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EventContext.EventCount">
            <summary> number of received events </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EventContext.Messages">
            <summary> return the <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.Messages"/> sent by a user </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EventContext.Changes">
            <summary> <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.Changes"/> return the changes per database container.
            Use <see cref="M:Friflo.Json.Fliox.Hub.Client.EventContext.GetChanges``2(Friflo.Json.Fliox.Hub.Client.EntitySet{``0,``1})"/> to get <b>strongly typed</b> container changes </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EventContext.EventInfo">
            <summary> return the number of <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.Messages"/> and <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.Changes"/> of the subscription event </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EventContext.IsOrigin">
            <summary> is true if the client is the origin of the event </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EventContext.SrcClient">
            <summary> is true if the client is the origin of the event </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.EventContext.Client">
            <summary> is private to be exposed only in Debugger </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventContext.GetChanges``2(Friflo.Json.Fliox.Hub.Client.EntitySet{``0,``1})">
            <summary>
            Give <b>strongly typed</b> access to the changes made to a container.
            The container is identified by the passed <paramref name="entitySet"/>.
            These changes contain the: <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Creates"/>, <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Upserts"/>,
            <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Deletes"/> and <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes`2.Patches"/> made to a container
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventContext.ApplyChangesTo(Friflo.Json.Fliox.Hub.Client.FlioxClient)">
            <summary> Apply all <see cref="P:Friflo.Json.Fliox.Hub.Client.EventContext.Changes"/> of the <see cref="T:Friflo.Json.Fliox.Hub.Client.EventContext"/> the given <paramref name="client"/> </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EventProcessor">
            <summary>
            An <see cref="T:Friflo.Json.Fliox.Hub.Client.EventProcessor"/> is used to process subscription events subscribed by a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>
            </summary>
            <remarks>
            By default a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> uses a <see cref="T:Friflo.Json.Fliox.Hub.Client.SynchronousEventProcessor"/> to handle subscription events
            in the thread the events arrive.
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.SynchronousEventProcessor">
            <summary>
            Handle subscription events in the thread a event message arrived.
            </summary>
            <remarks>
            E.g. In case of a <see cref="T:System.Net.WebSockets.WebSocket"/> in the thread reading data from the WebSocket stream.
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EventProcessorContext">
            <summary>
            An <see cref="T:Friflo.Json.Fliox.Hub.Client.EventProcessor"/> implementation used for UI based applications having a <see cref="T:System.Threading.SynchronizationContext"/>
            </summary>
            <remarks>
            The <see cref="T:Friflo.Json.Fliox.Hub.Client.EventProcessorContext"/> ensures that the handler methods passed to the <b>Subscribe*()</b> methods of
            <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> and <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> are called on the on the thread associated with
            the <see cref="T:System.Threading.SynchronizationContext"/>
            <br/>
            Depending on the application type <b>SynchronizationContext.Current</b> is null or not-null
            <list type="bullet">
              <item>
                In case of UI applications like WinForms, WPF or Unity <see cref="P:System.Threading.SynchronizationContext.Current"/> is not-null.<br/>
                These application types utilize <see cref="P:System.Threading.SynchronizationContext.Current"/> to enable calling all UI methods
                on the UI thread.
              </item> 
              <item>
                In case of unit-tests or Console / ASP.NET Core applications <see cref="P:System.Threading.SynchronizationContext.Current"/> is null.<br/>
                One way to establish a <see cref="T:System.Threading.SynchronizationContext"/> in these scenarios is to execute the whole
                application / unit test within the <b>Run()</b> method of <see cref="T:Friflo.Json.Fliox.Hub.Threading.SingleThreadSynchronizationContext"/>
              </item>
            </list>
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.EventProcessorQueue">
            <summary>
            Is a queuing <see cref="T:Friflo.Json.Fliox.Hub.Client.EventProcessor"/> giving an application full control when event callback are invoked.
            </summary>
            <remarks>
            In this case the application must frequently call <see cref="M:Friflo.Json.Fliox.Hub.Client.EventProcessorQueue.ProcessEvents"/> to apply changes to the
            <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>.
            This allows to specify the exact code point in an application (e.g. Unity) to call the handler
            methods of message and changes subscriptions.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.EventProcessorQueue.ProcessEvents">
            <summary>
            Need to be called frequently by application to process subscription events.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler">
            <summary>
            Defines signature of the handler method passed to <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>
            </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.SubscriptionEventHandler"/>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler`1">
            <summary>
            Defines signature of the handler method passed to <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage``1(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler{``0})"/>
            </summary>
            <seealso cref="T:Friflo.Json.Fliox.Hub.Client.SubscriptionEventHandler"/>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.IMessage">
            <summary>
            Expose the <see cref="P:Friflo.Json.Fliox.Hub.Client.IMessage.Name"/> and the <see cref="P:Friflo.Json.Fliox.Hub.Client.IMessage.RawParam"/> of a received message.
            Use <see cref="M:Friflo.Json.Fliox.Hub.Client.IMessage.GetParam``1(``0@,System.String@)"/> to get type safe access to the <see cref="P:Friflo.Json.Fliox.Hub.Client.IMessage.RawParam"/> of a message. 
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.IMessage.Name">
            <summary>message name</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.IMessage.RawParam">
            <summary>raw message parameter as JSON</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.IMessage.GetParam``1(``0@,System.String@)">
            <summary>
            Read the <see cref="P:Friflo.Json.Fliox.Hub.Client.IMessage.RawParam"/> as the given type <typeparamref name="TParam"/>.
            Return false and set <paramref name="error"/> in case <see cref="P:Friflo.Json.Fliox.Hub.Client.IMessage.RawParam"/> is incompatible to <typeparamref name="TParam"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.Message`1">
            <summary>
            Expose the <see cref="P:Friflo.Json.Fliox.Hub.Client.Message`1.Name"/>, the <see cref="P:Friflo.Json.Fliox.Hub.Client.Message`1.RawParam"/> and the type safe <see cref="M:Friflo.Json.Fliox.Hub.Client.Message`1.GetParam(`0@,System.String@)"/> of a received message.
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Message`1.Name">
            <summary>message name</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Message`1.RawParam">
            <summary>raw message parameter as JSON</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Message`1.GetParam(`0@,System.String@)">
            <summary>Return the message <paramref name="param"/></summary> without validation 
            <param name="param">the param value if conversion successful</param>
            <param name="error">contains the error message if conversion failed</param>
            <returns> true if successful; false otherwise </returns>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Message`1.GetParam``1(``0@,System.String@)">
            <summary>Return the message <paramref name="param"/> as the given type <typeparamref name="T"/> without validation</summary>
            <param name="param">the param value if conversion successful</param>
            <param name="error">contains the error message if conversion failed</param>
            <returns> true if successful; false otherwise </returns>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Message`1.#ctor(Friflo.Json.Fliox.Hub.Client.Event.InvokeContext@)">
            <summary>
            <see cref="P:Friflo.Json.Fliox.Hub.Client.Message`1.RawParam"/> is set to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.param"/> json.
            If json is null <see cref="P:Friflo.Json.Fliox.Hub.Client.Message`1.RawParam"/> is set to "null".
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.Message">
            <summary>
            Expose the <see cref="P:Friflo.Json.Fliox.Hub.Client.Message.Name"/> and the <see cref="P:Friflo.Json.Fliox.Hub.Client.Message.RawParam"/> of a received message.
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Message.Name">
            <summary>message name</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Message.RawParam">
            <summary>raw message parameter as JSON</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Message.GetParam``1(``0@,System.String@)">
            <summary>Return the message <paramref name="param"/></summary> without validation 
            <param name="param">the param value if conversion successful</param>
            <param name="error">contains the error message if conversion failed</param>
            <returns> true if successful; false otherwise </returns>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.SubscriptionProcessor">
            <summary>
            Used to process <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s received by a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>.  
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.SubscriptionProcessor.contextChanges">
            <summary> contain only <see cref="T:Friflo.Json.Fliox.Hub.Client.Changes"/> where <see cref="P:Friflo.Json.Fliox.Hub.Client.Changes.Count"/> > 0 </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.SubscriptionProcessor.ProcessEvent(Friflo.Json.Fliox.Hub.Client.FlioxClient,Friflo.Json.Fliox.Hub.Protocol.SyncEvent@,System.Int32)">
            <summary>
            Process the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasks"/> of the given <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>.
            These <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasks"/> are "messages" resulting from subscriptions registered by
            methods like <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChanges(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})"/>, <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeAllChanges(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler)"/> or
            <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.HubMessages">
            <summary>
            Used to group message/command methods by a single class.
            </summary>
            <remarks>
            Message/command methods can be added directly to a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> sub class.
            When adding many methods it can cause confusion between <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> own methods and the message/command methods.
            The intention is to use a sub class of <see cref="T:Friflo.Json.Fliox.Hub.Client.HubMessages"/> as a field in a class extending <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>.
            This establish differentiation between <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> own methods and message/command methods added
            to a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> sub class.
            <code >
            public class TestStore : FlioxClient
            {
                // --- commands
                public MyCommands test;
                
                public TestStore(FlioxHub hub) : base(hub) {
                    test = new MyCommands(this);
                }
            }
            
            public class MyCommands : HubMessages
            {
                public MyCommands(FlioxClient client) : base(client) { }
                
                public CommandTask &lt;string&gt; Cmd (string param) => send.Command &lt;string, string&gt;(param);
            }
            </code>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.HubMessages.send">
            <summary> Used to send typed messages / commands by classes extending <see cref="T:Friflo.Json.Fliox.Hub.Client.HubMessages"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Internal.ClientIntern.SetSubscriptionProcessor(Friflo.Json.Fliox.Hub.Client.SubscriptionProcessor)">
            <summary>
            Set a custom <see cref="M:Friflo.Json.Fliox.Hub.Client.Internal.ClientIntern.SubscriptionProcessor"/> to process subscribed database changes or messages (commands).<br/>
            E.g. notifying other application modules about created, updated, deleted or patches entities.
            To subscribe to database change events use <see cref="M:Friflo.Json.Fliox.Hub.Client.EntitySet`2.SubscribeChanges(Friflo.Json.Fliox.Hub.Client.Change,Friflo.Json.Fliox.Hub.Client.ChangeSubscriptionHandler{`0,`1})"/>.
            To subscribe to message events use <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage"/>.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Internal.ClientReadOnly.responseReaderPool">
            <summary>is null if <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.SupportPushEvents"/> == false</summary> 
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.Internal.EmptyDictionary`2">
            <summary>
            An immutable <see cref="T:System.Collections.Generic.IDictionary`2"/> implementation containing no entries.
            Used for methods returning an empty dictionary instead of null reference to avoid null checks or throwing
            a <see cref="T:System.NullReferenceException"/> when accessing the return value. 
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Internal.KeyEntity.EntityKeyT`2.GetId(`1)">
            <summary> prefer using <see cref="M:Friflo.Json.Fliox.Hub.Client.Internal.KeyEntity.EntityKeyT`2.GetKey(`1)"/>. Use only if <typeparamref name="TKey"/> is not utilized </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Internal.KeyEntity.EntityKeyT`2.SetId(`1,Friflo.Json.Fliox.JsonKey@)">
            <summary> prefer using <see cref="M:Friflo.Json.Fliox.Hub.Client.Internal.KeyEntity.EntityKeyT`2.SetKey(`1,`0)"/>. Use only if <typeparamref name="TKey"/> is not utilized </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Internal.Map.EntitySetInfo.index">
            <summary>index in <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.GetEntitySetInfos(Friflo.Json.Fliox.Hub.Client.FlioxClient)"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.Internal.Map.ClientFieldFilter">
            <summary>
            Ignore all fields / properties in a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> which are not of Type <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Internal.Peer`2.NullableEntity">
            Using the the unchecked <see cref="P:Friflo.Json.Fliox.Hub.Client.Internal.Peer`2.NullableEntity"/> must be an exception. Use <see cref="P:Friflo.Json.Fliox.Hub.Client.Internal.Peer`2.Entity"/> by default.
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Internal.SubRelations.map">
            key: <see cref="P:Friflo.Json.Fliox.Hub.Client.ReadRelationsFunction.Selector"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Internal.Set.JsonToEntities(System.Collections.Generic.ListOne{Friflo.Json.Fliox.JsonValue},System.Collections.Generic.List{Friflo.Json.Fliox.JsonKey},System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.EntityError})">
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Client.Internal.Set.EntitiesToJson(Friflo.Json.Fliox.Hub.Protocol.Models.EntityValue[],System.Collections.Generic.ListOne{Friflo.Json.Fliox.JsonValue}@,System.Collections.Generic.List{Friflo.Json.Fliox.JsonKey}@,System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.EntityError}@)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Internal.Set.EntitiesToJson(Friflo.Json.Fliox.Hub.Protocol.Models.EntityValue[],System.Collections.Generic.ListOne{Friflo.Json.Fliox.JsonValue}@,System.Collections.Generic.List{Friflo.Json.Fliox.JsonKey}@,System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.EntityError}@)">
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Client.Internal.Set.JsonToEntities(System.Collections.Generic.ListOne{Friflo.Json.Fliox.JsonValue},System.Collections.Generic.List{Friflo.Json.Fliox.JsonKey},System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.EntityError})"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.Internal.Set`2">
            Multiple instances of this class can be created when calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> without
            awaiting the result. Each instance is mapped to a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> / <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse"/> instance.
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Internal.Set`2.peerMap">
            <summary> key: <see cref="F:Friflo.Json.Fliox.Hub.Client.Internal.Peer`2.entity"/>.id </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Internal.Set`2.Peers">
            <summary> enable access to entities in debugger. Not used internally. </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Internal.Set`2.GetPeers">
            <summary> Note! Must be called only from <see cref="T:Friflo.Json.Fliox.Hub.Client.LocalEntities`2"/> to preserve maintainability </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Internal.Set`2.WritePretty">
            <summary> If true the serialization of entities to JSON is prettified </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.Internal.Set`2.WriteNull">
            <summary> If true the serialization of entities to JSON write null fields. Otherwise null fields are omitted </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Internal.Set`2.SyncPeerEntities(System.Collections.Generic.List{Friflo.Json.Fliox.JsonValue},System.Collections.Generic.List{Friflo.Json.Fliox.JsonKey},Friflo.Json.Fliox.Mapper.ObjectMapper,System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Client.ApplyInfo{`0,`1}})">
            called on create and upsert events
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Internal.Set`2.GetReadResultValues(Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult)">
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Remote.Tools.RemoteHostUtils.ResponseToJson(Friflo.Json.Fliox.Hub.Protocol.SyncResponse)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.Internal.Set`2.PatchPeerEntities(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Client.Patch{`0}},Friflo.Json.Fliox.Mapper.ObjectMapper,System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Client.ApplyInfo{`0,`1}})">
            Called on patch events
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.ClientOptions.WritePretty">
            <summary> If true the serialization of entities to JSON is prettified </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.ClientOptions.WriteNull">
            <summary> If true the serialization of entities to JSON write null fields. Otherwise null fields are omitted </summary>        
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.ClientOptions.DebugEventReceiver">
            <summary>
            An <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver"/> send subscribed events to a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> instance.<br/>
            Its its currently only used for testing.<br/>
            </summary>
            <remarks>
            <b>Note</b><br/>
            It must be set before calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> or assigning <see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.ClientId"/>.<br/>
            An <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver"/> is registered by an <see cref="P:Friflo.Json.Fliox.Hub.Client.FlioxClient.ClientId"/>.<br/>
            Changing the id would result in not receiving events a client subscribed with an old id.<br/>
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.StdCommands">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Client.StdCommands"/> contains all standard database commands. Its commands are prefixed with <b>std.*</b><br/>
            Each method creates a <see cref="T:Friflo.Json.Fliox.Hub.Client.CommandTask"/> and they are executed as a request
            when calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Echo(Friflo.Json.Fliox.JsonValue)">
            <summary>Echos the given parameter to assure the database is working appropriately. </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Echo``1(``0)">
            <summary>Echos the given parameter to assure the database is working appropriately. </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Delay(System.Int32)">
            <summary>A command that completes after a specified number of milliseconds. </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Containers">
            <summary>List all database containers</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Messages">
            <summary>List all database commands and messages</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Schema">
            <summary>Return the Schema assigned to the database</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Stats(System.String)">
            <summary>Return the number of entities of all containers (or the given container) of the database</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.TransactionBegin">
            <summary>Begin a transaction containing all subsequent <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncTask"/>'s.<br/>
            The transaction ends by either calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> or explicit by
            <see cref="M:Friflo.Json.Fliox.Hub.Client.StdCommands.TransactionCommit"/> / <see cref="M:Friflo.Json.Fliox.Hub.Client.StdCommands.TransactionRollback"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.TransactionCommit">
            <summary>Commit a transaction started previously with <see cref="M:Friflo.Json.Fliox.Hub.Client.StdCommands.TransactionBegin"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.TransactionRollback">
            <summary>Rollback a transaction started previously with <see cref="M:Friflo.Json.Fliox.Hub.Client.StdCommands.TransactionBegin"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.ExecuteRawSQL(Friflo.Json.Fliox.Hub.DB.Cluster.RawSql)">
            <summary>Execute a raw SQL query / statement</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Host(Friflo.Json.Fliox.Hub.DB.Cluster.HostParam)">
            <summary>Returns general information about the Hub like version, host, project and environment name</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Cluster">
            <summary>List all databases and their containers hosted by the Hub</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.User(Friflo.Json.Fliox.Hub.DB.Cluster.UserParam)">
            <summary>Return the groups of the current user. Optionally change the groups of the current user</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.StdCommands.Client(Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam)">
            <summary>Return client specific infos and adjust general client behavior like <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam.queueEvents"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.CommandTask">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Client.CommandTask"/> contains the command (<b>name</b> and <b>param</b>) send to an <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> using <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendCommand``1(System.String)"/>.
            Additional to a <see cref="T:Friflo.Json.Fliox.Hub.Client.MessageTask"/> a <see cref="T:Friflo.Json.Fliox.Hub.Client.CommandTask"/> also provide a command <see cref="P:Friflo.Json.Fliox.Hub.Client.CommandTask.RawResult"/> containing its execution result.
            </summary>
            <remarks>
            <b>Note</b>: For type safe access to the result use <see cref="T:Friflo.Json.Fliox.Hub.Client.CommandTask`1"/> returned by
            <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendCommand``2(System.String,``0)"/>
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.CommandTask.RawResult">
            <summary>Return the result of a command used as a command as JSON.
            JSON is "null" if the command doesn't return a result.
            For type safe access of the result use <see cref="M:Friflo.Json.Fliox.Hub.Client.CommandTask.ReadResult``1"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.CommandTask.ReadResult``1">
            <summary>
            Return a type safe result of a command.
            The result is null if the command doesn't return a result.
            Throws <see cref="T:Friflo.Json.Fliox.Mapper.JsonReaderException"/> if read fails.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.CommandTask.TryReadResult``1(``0@,Friflo.Json.Fliox.Mapper.JsonReaderException@)">
            <summary>
            Return a type safe result of a command.
            The result is null if the command doesn't return a result.
            Return false if read fails and set <paramref name="error"/>.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.CommandTask`1">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Client.CommandTask`1"/> contains the command (<b>name</b> and <b>param</b>) send to an <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> using <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendCommand``1(System.String)"/>.
            Its <see cref="P:Friflo.Json.Fliox.Hub.Client.CommandTask`1.Result"/> is available after calling <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/>.
            </summary>
            <remarks>
            Additional to a <see cref="T:Friflo.Json.Fliox.Hub.Client.MessageTask"/> a <see cref="T:Friflo.Json.Fliox.Hub.Client.CommandTask`1"/> also provide type safe access
            to the command <see cref="P:Friflo.Json.Fliox.Hub.Client.CommandTask`1.Result"/> after the task is synced successful.
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.DetectAllPatches">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Client.DetectAllPatches"/> is a container of <see cref="T:Friflo.Json.Fliox.Hub.Client.DetectPatchesTask"/>'s. <br/>
            It is returned by <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.DetectAllPatches"/> and contain <see cref="P:Friflo.Json.Fliox.Hub.Client.DetectAllPatches.EntitySetPatches"/> for
            all <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/>'s where entity patches are found.
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.DetectAllPatches.EntitySetPatches">
            <summary>List of detected <see cref="T:Friflo.Json.Fliox.Hub.Client.DetectPatchesTask"/>'s per <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/></summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.DetectAllPatches.PatchCount">
            <summary>Number of all detected entity patches</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.DetectAllPatches.Success">
            <summary>Is true in case all <see cref="P:Friflo.Json.Fliox.Hub.Client.DetectAllPatches.EntitySetPatches"/> applied successful</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Client.DetectAllPatches.GetPatches``2(Friflo.Json.Fliox.Hub.Client.EntitySet{``0,``1})">
            <summary>return type-safe patches of the given <paramref name="entitySet"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.MessageTask">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Client.MessageTask"/> contains the message / command (<b>name</b> and <b>param</b>) sent to
            an <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> by <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SendMessage(System.String)"/>
            </summary>
            <remarks>
            The <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> forward the message (or command) as en event to all clients subscribed to the message. <br/>
            If sending the message to the <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> is successful <see cref="P:Friflo.Json.Fliox.Hub.Client.SyncTask.Success"/> is true. <br/>
            <i>Notes:</i>
            <list type="bullet">
              <item> Messages in contrast to commands return no result. </item>
              <item> The result of a command is available via <see cref="P:Friflo.Json.Fliox.Hub.Client.CommandTask`1.Result"/> </item>
              <item> The response of messages and commands provide no information that they are received as events by subscribed clients. </item>
            </list>
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.MessageTask.EventTargets">
            <summary>
            Restrict the clients receiving the message as an event in case they setup a subscription with <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SubscribeMessage(System.String,Friflo.Json.Fliox.Hub.Client.MessageSubscriptionHandler)"/>.
            </summary>
            <remarks>
            A default <see cref="P:Friflo.Json.Fliox.Hub.Client.MessageTask.EventTargets"/> instance is not restricted to specific target users, clients or groups. <br/>
            So a message is forwarded by the Hub as an event to all clients subscribed to the message. <br/>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.QueryTask`2.maxCount">
            <summary> return <see cref="F:Friflo.Json.Fliox.Hub.Client.QueryTask`2.maxCount"/> number of entities within <see cref="P:Friflo.Json.Fliox.Hub.Client.QueryTask`2.Result"/>.
            After task execution <see cref="P:Friflo.Json.Fliox.Hub.Client.QueryTask`2.ResultCursor"/> is not null if more entities available.
            To access them create new query and assign <see cref="P:Friflo.Json.Fliox.Hub.Client.QueryTask`2.ResultCursor"/> to its <see cref="F:Friflo.Json.Fliox.Hub.Client.QueryTask`2.cursor"/>.   
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.QueryTask`2.cursor">
            <summary> <see cref="F:Friflo.Json.Fliox.Hub.Client.QueryTask`2.cursor"/> is used to proceed iterating entities of a previous query
            which set <see cref="F:Friflo.Json.Fliox.Hub.Client.QueryTask`2.maxCount"/>. <br/>
            Therefore assign <see cref="P:Friflo.Json.Fliox.Hub.Client.QueryTask`2.ResultCursor"/> of the previous to <see cref="F:Friflo.Json.Fliox.Hub.Client.QueryTask`2.cursor"/>. </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.QueryTask`2.ResultCursor">
            <summary> Is not null after task execution if more entities available.
            To access them create a new query and assign <see cref="P:Friflo.Json.Fliox.Hub.Client.QueryTask`2.ResultCursor"/> to its <see cref="F:Friflo.Json.Fliox.Hub.Client.QueryTask`2.cursor"/>. </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.FindFunction`2">
            <summary>originally extended SyncFunction. Its members are now in <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncTask"/> </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FindFunction`2.Success">
            <summary>
            Is true in case task execution was successful. Otherwise false. If false <see cref="P:Friflo.Json.Fliox.Hub.Client.FindFunction`2.Error"/> property is set. 
            </summary>
            <exception cref="T:Friflo.Json.Fliox.Hub.Client.TaskNotSyncedException"></exception>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.FindFunction`2.Error">
            <summary>The error caused the task failing. Return null if task was successful - <see cref="P:Friflo.Json.Fliox.Hub.Client.FindFunction`2.Success"/> == true</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.ReadRelationsFunction">
            <summary>originally extended SyncFunction. Its members are now in <see cref="T:Friflo.Json.Fliox.Hub.Client.SyncTask"/> </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.ReadRelationsFunction.Success">
            <summary>
            Is true in case task execution was successful. Otherwise false. If false <see cref="P:Friflo.Json.Fliox.Hub.Client.ReadRelationsFunction.Error"/> property is set. 
            </summary>
            <exception cref="T:Friflo.Json.Fliox.Hub.Client.TaskNotSyncedException"></exception>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Client.ReadRelationsFunction.Error">
            <summary>The error caused the task failing. Return null if task was successful - <see cref="P:Friflo.Json.Fliox.Hub.Client.ReadRelationsFunction.Success"/> == true</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.IReadRelationsTask`1">
            ensure all tasks returning <see cref="T:Friflo.Json.Fliox.Hub.Client.ReadRelations`1"/>'s provide the same interface
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.Change">
            <summary>Filter type used to specify the type of an entity change.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Change.None">
            <summary>Shortcut to unsubscribe from all entity change types.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Change.All">
            <summary>Shortcut to subscribe to all types of entity changes.</summary>
            <remarks>
            These ase <see cref="F:Friflo.Json.Fliox.Hub.Client.Change.create"/>, <see cref="F:Friflo.Json.Fliox.Hub.Client.Change.upsert"/>, <see cref="F:Friflo.Json.Fliox.Hub.Client.Change.merge"/> and <see cref="F:Friflo.Json.Fliox.Hub.Client.Change.delete"/>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Change.create">
            <summary>filter change events of created entities.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Change.upsert">
            <summary>filter change events of upserted entities.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Change.merge">
            <summary>filter change events of entity patches.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Client.Change.delete">
            <summary>filter change events of deleted entities.</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Client.UserInfo">
            <summary>Contains the tuple of <see cref="F:Friflo.Json.Fliox.Hub.Client.UserInfo.userId"/>, <see cref="F:Friflo.Json.Fliox.Hub.Client.UserInfo.token"/> and <see cref="F:Friflo.Json.Fliox.Hub.Client.UserInfo.clientId"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.ClusterDB">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.DB.Cluster.ClusterDB"/> store information about databases hosted by the Hub: <br/>
            - available containers aka tables per database <br/>
            - available commands per database <br/>
            - the schema assigned to each database
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.ClusterStore">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.DB.Cluster.ClusterStore"/> provide information about databases hosted by the Hub: <br/>
            - available containers aka tables per database <br/>
            - available commands per database <br/>
            - the schema assigned to each database
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.DB.Cluster.ClusterService.ApplyAuthorizedDatabaseFilter(Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Remove all ids from given <paramref name="read"/> task the user ist not authorized to access,  
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.DbContainers">
            <summary><see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbContainers.containers"/> and <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbContainers.storage"/> type of a database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbContainers.id">
            <summary>database name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbContainers.storage">
            <summary><see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbContainers.storage"/> type. e.g. memory, file-system, ...</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbContainers.containers">
            <summary>list of database <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbContainers.containers"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbContainers.defaultDB">
            <summary>true if the database is the default database of a Hub</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.DbMessages">
            <summary><see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbMessages.commands"/> and <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbMessages.messages"/> of a database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbMessages.id">
            <summary>database name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbMessages.commands">
            <summary>list of database <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbMessages.commands"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbMessages.messages">
            <summary>list of database <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbMessages.messages"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema"/> can be assigned to a database to specify its <b>containers</b>, <b>commands</b> and <b>messages</b>.<br/>
            The types used by the Schema are declared within <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema.jsonSchemas"/>.<br/>
            The type referenced by the tuple <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema.schemaName"/> / <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema.schemaPath"/> specify the
            database containers, commands and messages. 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema.id">
            <summary>database name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema.schemaName">
            <summary>refer a type definition of the JSON Schema referenced with <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema.schemaPath"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema.schemaPath">
            <summary>refer a JSON Schema in <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema.jsonSchemas"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbSchema.jsonSchemas">
            <summary>map of <b>JSON Schemas</b> each containing a set of type definitions.<br/>
            Each JSON Schema is identified by its unique path</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.DbStats">
            <summary>list of container statistics. E.g. the number of entities per container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.DbStats.containers">
            <summary>list of container statistics - number of entities per container</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.ContainerStats">
            <summary>statistics of a single container. E.g. the number of entities in a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ContainerStats.name">
            <summary>container name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ContainerStats.count">
            <summary>number of entities / records within a container</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.TransactionResult">
            <summary>return the execution result performed by a transaction.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.TransactionResult.executed">
            <summary>
            The execution performed by the transaction.<br/>
            In case any task in the transaction failed the transaction performs a <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.TransactionCommand.Rollback"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo">
            <summary>general information about a Hub</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo.hostName">
            <summary>host name used to identify a specific host in a network.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo.hostVersion">
            <summary>host version</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo.flioxVersion">
            <summary>Fliox library version</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo.projectName">
            <summary>project name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo.projectWebsite">
            <summary>link to a website describing project and Hub</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo.envName">
            <summary>environment name. e.g. 'dev', 'test', 'staging', 'prod'</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo.envColor">
            <summary>
            the color used to display the environment name in GUI's using CSS color format.<br/>
            E.g. using red for a production environment: "#ff0000" or "rgb(255 0 0)"
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo.pubSub">
            <summary> is true if host support Pub-Sub.</summary>
            <remarks> if true <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.EventDispatcher"/> is assigned </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostInfo.routes">
            <summary>routes configures by <see cref="T:Friflo.Json.Fliox.Hub.Remote.HttpHost"/> - commonly below <c>/fliox</c></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.HostGCMemory">
            <summary> See <a href="https://learn.microsoft.com/en-us/dotnet/api/system.gcmemoryinfo">GCMemoryInfo</a></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.HostCluster">
            <summary>All <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostCluster.databases"/> hosted by Hub</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostCluster.databases">
            <summary>list of <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.HostCluster.databases"/> hosted by Hub</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.UserResult.counts">
            <summary>number executed requests and tasks per database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam.ensureClientId">
            <summary>Return the client id set in <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> or creates a new one in case is was not set.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam.queueEvents">
            <summary>
            If <b>false</b> the hub try to send events to a client when the events are emitted.
            Sending events to a disconnected client will never arrive. <br/>
            If <b>true</b> the hub will store all unacknowledged events for a client in a FIFO queue and send them on reconnects.  
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientResult.queueEvents">
            <summary> returns true if the host queue events for the client in case of disconnects </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientResult.queuedEvents">
            <summary>
            return number of queued events not acknowledged by the client.
            Events are queued only if the client instruct the Hub to queue events by setting <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam.queueEvents"/> = true 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientResult.clientId">
            <summary>return the client id set in the <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>. Can be null.<br/>
            A new client id is created in case any task requires a client id and the <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> did not set a client id.<br/>
            E.g. <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam.ensureClientId"/> = true or <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam.queueEvents"/> = true </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ClientResult.subscriptionEvents">
            <summary>number of sent or queued client events and its message and change subscriptions</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.SubscriptionEvents">
            <summary>number of sent or queued client events and its message and change subscriptions</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.SubscriptionEvents.seq">
            <summary>number of events sent to a client</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.SubscriptionEvents.queued">
            <summary>number of queued events not acknowledged by a client</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.SubscriptionEvents.queueEvents">
            <summary>true if client is instructed to queue events for reliable event delivery in case of reconnects</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.SubscriptionEvents.connected">
            <summary>true if client is connected. Non remote client are always connected</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.SubscriptionEvents.endpoint">
            <summary>
            The endpoint of the client events are sent to.<br/>
            E.g. <c>ws:[::1]:52089</c> for WebSockets, <c>udp:127.0.0.1:60005</c> for UDP or <c>in-process</c>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.SubscriptionEvents.messageSubs">
            <summary>message / command subscriptions of a client</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.SubscriptionEvents.changeSubs">
            <summary>change subscriptions of a client</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.ChangeSubscription">
            <summary>change subscription for a specific container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ChangeSubscription.container">
            <summary>name of subscribed container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ChangeSubscription.changes">
            <summary>type of subscribed changes like create, upsert, delete and patch</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ChangeSubscription.filter">
            <summary>filter to narrow the amount of change events</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.RequestCount">
            <summary>number of requests and tasks executed per database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RequestCount.db">
            <summary>database name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RequestCount.requests">
            <summary>number of executed requests</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RequestCount.tasks">
            <summary>number of executed tasks</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.ChangeType">
            <summary>Filter type used to specify the type of an entity change</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ChangeType.create">
            <summary>filter change events of created entities.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ChangeType.upsert">
            <summary>filter change events of upserted entities.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ChangeType.merge">
            <summary>filter change events of entity patches.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ChangeType.delete">
            <summary>filter change events of deleted entities.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ModelFilesQuery.db">
            <summary>specific database or null to retrieve all available models</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.ModelFilesQuery.type">
            <summary>specific model type - e.g. 'typescript' or null to retrieve all available model types</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.NamespaceDoc">
            <summary>
            Contains the <see cref="T:Friflo.Json.Fliox.Hub.DB.Cluster.ClusterStore"/> to get the configuration of databases hosted by a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/>   
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.RawColumnType">
            The column type used by an SQL database. 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawColumnType.Bool">
            Not supported by all SQL database. SQLite, SQL Server, MySQL, MariaDB: tinyint 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawColumnType.Uint8">
            Not supported by all SQL database. SQLite: integer, PostgreSQL: smallint 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawColumnType.Int16">
            Not supported by all SQL database. SQLite: integer 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawColumnType.Int32">
            Not supported by all SQL database. SQLite: integer 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawColumnType.DateTime">
            Not supported by all SQL database. SQLite: text 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawColumnType.Guid">
            Not supported by all SQL database. SQLite: text, MySQL: varchar(36) 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawColumnType.Float">
            Not supported by all SQL database. SQLite: real 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawColumnType.JSON">
            Not supported by all SQL database. SQLite: text, SQL Server: nvarchar(max), MariaDB: longtext 
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Cluster.RawSql">
            <summary>Used to execute raw SQL commands</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawSql.command">
            <summary>An SQL statement like: <c>select * from table_name;</c></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawSql.schema">
            <summary> If true the response contains the schema <see cref="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawSqlResult.columns"/> in the response</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.DB.Cluster.RawSqlResult.rowCount">
            <summary>number of returned rows</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawSqlResult.columns">
            <summary>The columns returned by a raw SQL query</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Cluster.RawSqlResult.data">
            <summary>An array of all query result values. In total: <see cref="P:Friflo.Json.Fliox.Hub.DB.Cluster.RawSqlResult.rowCount"/> * <see cref="P:Friflo.Json.Fliox.Hub.DB.Cluster.RawSqlResult.columnCount"/> values</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Monitor.MonitorDB">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.DB.Monitor.MonitorDB"/> store access information of the Hub and its databases:<br/>
            - request and task count executed per user <br/>
            - request and task count executed per client. A user can access without, one or multiple client ids. <br/>
            - events sent to (or buffered for) clients subscribed by these clients. <br/>
            - aggregated access counts of the Hub in the last 30 seconds and 30 minutes.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Monitor.MonitorStore">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.DB.Monitor.MonitorStore"/> expose access information of the Hub and its databases:<br/>
            - request and task count executed per user <br/>
            - request and task count executed per client. A user can access without, one or multiple client ids. <br/>
            - events sent to (or buffered for) clients subscribed by these clients. <br/>
            - aggregated access counts of the Hub in the last 30 seconds and 30 minutes.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.DB.Monitor.MonitorStore.ClearStats(Friflo.Json.Fliox.Hub.DB.Monitor.ClearStats)">
            <summary>Reset all request, task and event counters</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Monitor.HostHits">
            <summary>number of requests and tasks executed by the host. Container contains always a single record</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.HostHits.id">
            <summary>host name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.HostHits.counts">
            <summary>number of executed requests and tasks per database</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Monitor.UserHits">
            <summary>all user clients and number of executed user requests and tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.UserHits.id">
            <summary>user id </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.UserHits.clients">
            <summary>list of clients owned by a user</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.UserHits.counts">
            <summary>number executed requests and tasks per database</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Monitor.ClientHits">
            <summary>information about requests, tasks, events and subscriptions of a client</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.ClientHits.id">
            <summary>client id </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.ClientHits.user">
            <summary>user owning the client</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.ClientHits.counts">
            <summary>number executed requests and tasks per database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.ClientHits.subscriptionEvents">
            <summary>number of sent or queued client events and its message and change subscriptions</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Monitor.HistoryHits">
            <summary>aggregated counts of latest requests. Each record uses a specific aggregation interval.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.HistoryHits.id">
            <summary>time in seconds for an aggregation interval</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.HistoryHits.counters">
            <summary>number of requests executed in each interval</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.Monitor.HistoryHits.lastUpdate">
            <summary>last update of the <see cref="T:Friflo.Json.Fliox.Hub.DB.Monitor.HistoryHits"/> record</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.Monitor.NamespaceDoc">
            <summary>
            Contains the <see cref="T:Friflo.Json.Fliox.Hub.DB.Monitor.MonitorStore"/> providing request statistics of a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/>   
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.NamespaceDoc">
            <summary>
            Contains the <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore"/> used to get or change user access permissions of a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/>   
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator">
            <summary>
            Performs user authentication by validating the <b>user</b> and <b>token</b> of every request<br/>
            Performs authorization for successful authenticated users by applying their assigned permissions.<br/>
            </summary>
            <remarks>
            <list type="bullet">
              <item>
                To avoid loosing access to the Hub accidentally following operations are not permitted:<br/>
                - Delete user <b>admin</b><br/>
                - Change permission <b>admin</b><br/>
                - Change role <b>hub-admin</b>
              </item>
              <item>
                The permission <b>.all-users</b> - if available - is used for authenticated and anonymous users.<br/>
              </item>
              <item>
                User permissions and roles are transparently defined and stored in the <b>user_db</b>.<br/>
                So authorization is fully documented by these two containers.
              </item>
              <item>
                User permissions and roles are cached for successful authenticated users.<br/>
                This enables instant task authorization and reduces the number of reads to the <b>user_db</b> significant.
              </item>
            </list>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator.anonymous">
            <summary><see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.User"/> instance used for all unauthenticated users</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator.allUsers">
            <summary>Contains authorization permissions for all users</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator.IsSynchronous(Friflo.Json.Fliox.Hub.Protocol.SyncRequest)">
            <summary>
            <see cref="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator.Authenticate(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> can run synchronous if already successful authenticated or a general
            authentication error occurred.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator.PreAuth(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.Auth.PreAuthType@,Friflo.Json.Fliox.Hub.Host.Auth.User@)">
            <summary>returns true if authentication can be executed synchronously</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthRole">
            <summary>
            Used to store the rights given by <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.taskRights"/> and <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.hubRights"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthRole.taskAuthorizers">
            <summary> assigned by <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.taskRights"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthRole.hubPermission">
            <summary> assigned by <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.hubRights"/> </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthInfo">
            <summary>
            Used to aggregated authorizers, permissions, groups and roles for a specific user. 
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthExtensions.SetAdminPermissions(Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator,System.String)">
            <summary>
            Set default admin permissions records in the user database to enable Hub access with user admin.<br/>
            </summary>
            <remarks>
            - create user credential: <b>admin</b> if not exist<br/>
            - set user permission: <b>admin</b> with role <b>hub-admin</b><br/>
            - set role: <b>hub-admin</b> granting full access to all databases<br/>
            <br/>
            This enables access to all Hub databases as user <b>admin</b> without accessing the user database directly.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthExtensions.SubscribeUserDbChanges(Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator,Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher)">
            <summary>
            Subscribe changes to <b>user_db</b> <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.permissions"/> and <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.roles"/> to 
            applying these changes to users instantaneously.<br/>
            <br/>
            Without subscribing <b>user_db</b> changes they are effective after a call to <see cref="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.ClearAuthCache"/>
            or after a server restart.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDB.ID.Server">
            <summary>"userId" used for a <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore"/> to perform user authentication.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDB.ID.AuthenticationUser">
            <summary>"userId" used for a <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore"/> to request a user authentication with its token</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDatabaseAuthenticator">
            <summary>
            Authenticate users stored in the user database.
            </summary>
            <remarks>
            If user authentication succeed it returns also the roles attached to a user to enable authorization for each task.
            The schema of the user database is defined in <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore"/>.
            <br/>
            The access to the user database itself requires also authentication by one of the predefined users:
            <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDB.ID.AuthenticationUser"/> or <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDB.ID.Server"/>.
            <br></br>
            A <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDB.ID.AuthenticationUser"/> user is only able to <see cref="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDatabaseAuthenticator.AuthenticateAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> itself.
            A <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDB.ID.Server"/> user is able to read credentials and roles stored in a user database.
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore">
            <summary>
            Control individual user access to database containers and commands. <br/>
            Each <b>user</b> has a set of <b>roles</b> stored in container <b>permissions</b>. <br/>
            Each <b>role</b> in container <b>roles</b> has a set of <b>rights</b> which grant or deny container access or command execution. 
            </summary>
            <remarks>
            <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore"/> can also be used as a non thread safe <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.IUserAuth"/> implementation.
            For a thread safe <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.IUserAuth"/> implementation use <see cref="N:Friflo.Json.Fliox.Hub.DB.UserAuth"/>.
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.ID.AllUsers">
            <summary>user id in <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.permissions"/> used for all users - authenticated and anonymous</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.ID.AuthenticatedUsers">
            <summary>user id in <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.permissions"/> used for authenticated users</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.ID.Admin">
            <summary>user id in <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.permissions"/> used for Hub administrator</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.ID.HubAdmin">
            <summary>role id in <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.roles"/> used to enable full Hub access</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.ID.ClusterInfo">
            <summary>role id in <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.roles"/> used to enable reading cluster database</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.AuthenticateUser(Friflo.Json.Fliox.Hub.DB.UserAuth.Credentials)">
            <summary>authenticate user <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.Credentials"/>: <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Credentials.userId"/> and <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Credentials.token"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserCredential">
            <summary>contains a <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserCredential.token"/> assigned to a user used for authentication</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserCredential.id">
            <summary>user id</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserCredential.token">
            <summary>user token</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserPermission">
            <summary>Set of <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserPermission.roles"/> assigned to a user used for authorization</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserPermission.id">
            <summary>
            user id.<br/>
            id's with specific behavior:<br/>
            .all-users - specify permissions for authenticated and non authenticated users.<br/> 
            .authenticated-users - specify permissions for authenticated users.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserPermission.roles">
            <summary>set of <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserPermission.roles"/> assigned to a user</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.Role">
            <summary>Contains a set of <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.taskRights"/> used for task authorization</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.id">
            <summary><see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.Role"/> name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.taskRights">
            <summary>a set of <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.taskRights"/> used for task authorization</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.hubRights">
            <summary>general request / connection rights for Hub access</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.description">
            <summary>optional <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.description"/> explaining a <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.Role"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserTarget">
            <summary>
            contain the <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserTarget.groups"/> assigned to a user.<br/>
            These groups are used to enable forwarding of message events only to users of specific groups.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserTarget.id">
            <summary>user id</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserTarget.groups">
            <summary>list of <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserTarget.groups"/> assigned to a user</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.Credentials">
            <summary>user <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.Credentials"/> used for authentication</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.AuthResult">
            <summary>Result of <see cref="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore.AuthenticateUser(Friflo.Json.Fliox.Hub.DB.UserAuth.Credentials)"/> command</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.DB.UserAuth.AuthResult.isValid">
            <summary>true if authentication was successful</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStoreSubscriber">
            <summary>
            Used to invalidate cached see cref="Host.Auth.Authenticator.users"/> in case:
            - a user permission changes
            - a role assigned to a user changes
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStoreSubscriber.AddAffectedUsers(System.Collections.Generic.HashSet{Friflo.Json.Fliox.ShortString},System.String[])">
            Iterate all users and add those to <paramref name="affectedUsers"/> having any of the given <paramref name="roles"/>.
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.AuthenticateNone">
            <summary>
            Used as default <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator"/> in a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/>.<br/>
            All users accessing a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> are not authenticated - <see cref="P:Friflo.Json.Fliox.Hub.Host.SyncContext.Authenticated"/> = false <br/>
            Execution of all user tasks are authorized. The <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.User.taskAuthorizer"/> and <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.User.hubPermission"/>
            of <see cref="P:Friflo.Json.Fliox.Hub.Host.SyncContext.User"/> grant full access.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator">
            <summary>
            Performs authentication and authorization by checking <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.userId"/> and <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.token"/>
            in every <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> call.
            </summary>
            <remarks>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator"/> is mutable. Its <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator.users"/> and <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator.registeredPredicates"/> are subject to change.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator.ValidateClientId(Friflo.Json.Fliox.Hub.Host.Auth.ClientController,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Validate <see cref="F:Friflo.Json.Fliox.Hub.Host.SyncContext.clientId"/> and returns <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.ClientIdValidation"/> result.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator.RegisterPredicate(System.String,Friflo.Json.Fliox.Hub.Host.Auth.AuthPredicate)">
            <summary>
            Register a predicate function by the given <paramref name="name"/> which enables custom authorization via code,
            which cannot be expressed by one of the provided <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.TaskRight"/> implementations.
            If called its parameters are intended to filter the aspired condition and return true if task execution is granted.
            To reject task execution it returns false.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator.RegisterPredicate(Friflo.Json.Fliox.Hub.Host.Auth.AuthPredicate)">
            <summary>
            Register a predicate function which enables custom authorization via code, which cannot be expressed by one of the
            provided <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.TaskRight"/> implementations.
            The <paramref name="predicate"/> is registered by its delegate name.
            If called its parameters are intended to filter the aspired condition and return true if task execution is granted.
            To reject task execution it returns false.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.ClientIdValidation">
            <summary>
            Represent the result of client id validation returned by <see cref="M:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator.ValidateClientId(Friflo.Json.Fliox.Hub.Host.Auth.ClientController,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>  
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.AuthState">
            <summary>
            Contains the authentication and authorization result of <see cref="M:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator.AuthenticateAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>.
            The authentication is performed for every <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> call. 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.AuthState.user">
            <summary><see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.AuthState.user"/> is never null after calling <see cref="M:Friflo.Json.Fliox.Hub.Host.SyncContext.AuthenticationFailed(Friflo.Json.Fliox.Hub.Host.Auth.User,System.String,Friflo.Json.Fliox.Hub.Host.Auth.TaskAuthorizer,Friflo.Json.Fliox.Hub.Host.Auth.HubPermission)"/>
            or <see cref="M:Friflo.Json.Fliox.Hub.Host.SyncContext.AuthenticationSucceed(Friflo.Json.Fliox.Hub.Host.Auth.User,Friflo.Json.Fliox.Hub.Host.Auth.TaskAuthorizer,Friflo.Json.Fliox.Hub.Host.Auth.HubPermission)"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.ClientController">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.ClientController"/> us used to create unique client ids
            </summary>
            <remarks>
            It creates a unique client id for a given <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.User"/> by <see cref="M:Friflo.Json.Fliox.Hub.Host.Auth.ClientController.NewClientIdFor(Friflo.Json.Fliox.Hub.Host.Auth.User)"/> or
            checks if a given client id can be used (added) for a given <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.User"/> by <see cref="M:Friflo.Json.Fliox.Hub.Host.Auth.ClientController.UseClientIdFor(Friflo.Json.Fliox.Hub.Host.Auth.User,Friflo.Json.Fliox.ShortString@)"/>.
            Multiple client ids can be added to a <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.User"/>. Once added to a <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.User"/> the client id
            cannot be used (added) by another <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.User"/>.
            <br/>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.ClientController"/> is used to:
            <list type="bullet">
              <item> create / add unique client ids by <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.ClientController"/> </item>
              <item> enables sending Push messages (events) for protocols supporting this like WebSocket's </item>
              <item> enables monitoring request / execution statistics of <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> </item>
            </list>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.ClientController.clients">
            key: clientId
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.HubPermission">
            <summary>
            Define the general Hub permissions. For now this apply only to event processing. <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.HubPermission.queueEvents"/>  
            </summary>
            <remarks>
            Task specific permissions are defined by <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.TaskAuthorizer"/>.
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.HubPermission.queueEvents">
            <summary>
            If true events are stored for user client to resent unacknowledged events on reconnects.
            <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.queueEvents"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.NamespaceDoc">
            <summary>
            Performs user authentication and authorization utilizing the <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbContainerRight">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbContainerRight"/> grant <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbContainerRight.database"/> access for the given <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbContainerRight.containers"/>
            based on a set of <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.ContainerAccess.operations"/>. <br/>
            E.g. create, read, upsert, delete, query or aggregate (count)<br/>
            It also allows subscribing database changes by <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.ContainerAccess.subscribeChanges"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbContainerRight.database">
            <summary>a specific database: 'test_db', multiple databases by prefix: 'test_*', all databases: '*'</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbContainerRight.containers">
            <summary>grant execution of operations and subscriptions on listed <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbContainerRight.containers"/> </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.ContainerAccess">
            <summary>Grant execution of specific container operations and subscriptions</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.ContainerAccess.name">
            <summary>Container name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.ContainerAccess.operations">
            <summary>Set of granted operation types</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.ContainerAccess.subscribeChanges">
            <summary>Set of granted change subscriptions</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType">
            <summary>Use to allow specific container operations in <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.ContainerAccess"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.create">
            <summary>allow to create entities in a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.upsert">
            <summary>allow to upsert entities in a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.delete">
            <summary>allow to delete entities in a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.deleteAll">
            <summary>allow to delete all container entities</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.merge">
            <summary>allow to patch entities in a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.read">
            <summary>allow to read entities in a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.query">
            <summary>allow to query entities in a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.aggregate">
            <summary>allow to aggregate - count - entities in a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.mutate">
            <summary>allow to mutate - create, upsert, delete and patch - entities in a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.OperationType.full">
            <summary>allow all operation types in a container</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbFullRight">
            <summary>
            Allow full access to the given <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbFullRight.database"/>.<br/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbFullRight.database">
            <summary>a specific database: 'test_db', multiple databases by prefix: 'test_*', all databases: '*'</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbTaskRight">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbTaskRight"/> grant <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbTaskRight.database"/> access by a set of task <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbTaskRight.types"/>. <br/> 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbTaskRight.database">
            <summary>a specific database: 'test_db', multiple databases by prefix: 'test_*', all databases: '*'</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.DbTaskRight.types">
            <summary>set fo task types like: create, read, upsert, delete, query, ...</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.HubRights">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.HubRights"/> used to set general request / connection permissions.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.HubRights.queueEvents">
            <summary>
            If <b>true</b> the hub store all unacknowledged events for a client in a FIFO queue and send them on reconnects.<br/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.PredicateRight.names">
            <summary>a specific predicate: 'TestPredicate', multiple predicates by prefix: 'Test*', all predicates: '*'</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SendMessageRight">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SendMessageRight"/> allows sending messages to a <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SendMessageRight.database"/> by a set of <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SendMessageRight.names"/>.<br/>
            <br/>
            Note: commands are messages - so permission of sending commands is same as for messages.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SendMessageRight.database">
            <summary>a specific database: 'test_db', multiple databases by prefix: 'test_*', all databases: '*'</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SendMessageRight.names">
            <summary>a specific message: 'std.Echo', multiple messages by prefix: 'std.*', all messages: '*'</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SubscribeMessageRight">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SubscribeMessageRight"/> allows subscribing messages send to a <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SubscribeMessageRight.database"/>.<br/>
            <br/>
            Note: commands are messages - so permission of subscribing commands is same as for messages.  
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SubscribeMessageRight.database">
            <summary>a specific database: 'test_db', multiple databases by prefix: 'test_*', all databases: '*'</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.SubscribeMessageRight.names">
            <summary>a specific message: 'std.Echo', multiple messages by prefix: 'std.*', all messages: '*'</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.TaskRight">
            <summary>
            Each <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.Role"/> has a set of <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.taskRights"/>. <br/>
            Each <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Rights.TaskRight"/> is a rule used to grant a specific database operation or command execution.<br/>
            The database operation or command execution is granted if any of it <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.Role.taskRights"/>
            grant access.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.Rights.TaskRight.description">
            <summary>optional description explaining the Right</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.TaskAuthorizer">
            <summary>
            Used to authorize <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/>'s.<br/>
            All <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.TaskAuthorizer"/> implementations are immutable.
            </summary>
            <remarks>
            This <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.TaskAuthorizer"/> it stored at <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.AuthState.taskAuthorizer"/>.
            The <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.AuthState.taskAuthorizer"/> is set via <see cref="M:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator.AuthenticateAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> for
            <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.AuthState.authenticated"/> and for not <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.AuthState.authenticated"/> users.
            </remarks> 
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Auth.TaskAuthorizer.AddAuthorizedDatabases(System.Collections.Generic.HashSet{Friflo.Json.Fliox.Hub.Host.Auth.DatabaseFilter})">
            <summary>
            Create a set of <paramref name="databaseFilters"/> used to filter
            <see cref="T:Friflo.Json.Fliox.Hub.DB.Cluster.ClusterStore"/> read and query results available to a user.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Auth.User">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.User"/> instance store credentials, <see cref="F:Friflo.Json.Fliox.Hub.Host.Auth.User.clients"/> and permissions of a user. <br/>
            Permissions: <br/>
            <see cref="P:Friflo.Json.Fliox.Hub.Host.Auth.User.TaskAuthorizer"/> to authorize task execution.<br/>
            <see cref="P:Friflo.Json.Fliox.Hub.Host.Auth.User.HubPermission"/> for general - non task specific - permissions.<br/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.User.userId">
            not null 
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Auth.User.TaskAuthorizer">
            not null 
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Auth.User.HubPermission">
            not null 
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Auth.User.Roles">
            not null 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.User.token">
            nullable 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.User.taskAuthorizer">
            not null 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.User.hubPermission">
            not null 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.User.roles">
            nullable 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.User.requestCounts">
            <b>Note</b> requires lock when accessing. Did not use ConcurrentDictionary to avoid heap allocation
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Auth.UserClient.requestCounts">
            <b>Note</b> requires lock when accessing. Did not use ConcurrentDictionary to avoid heap allocation
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.DatabaseService">
            <summary>
            A single <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseService"/> is assigned to every <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/>.
            It can be extended to intercept / customize execution of commands or database operations.  
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseService.#ctor(Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue)">
            <summary>
            If <paramref name="queue"/> is set <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> are queued for execution otherwise
            they are executed as they arrive.
            </summary>
            <remarks>
            To execute queued requests (<paramref name="queue"/> is set) <see cref="M:Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue.ExecuteQueuedRequestsAsync"/>
            need to be called regularly.<br/>
            This enables requests / task execution on the calling thread. <br/>
            This mode guarantee sequential execution of messages, commands and container operations like
            read, query, create, upsert, merge and delete.<br/>
            So using lock's or other thread synchronization mechanisms are not necessary.
            </remarks> 
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseService.AddMessageHandler``1(System.String,Friflo.Json.Fliox.Hub.Host.HostMessageHandler{``0})">
            <summary>
            Add a synchronous message handler method with a method signature like:
            <code>
            void TestMessage(Param&lt;string&gt; param, MessageContext context) { ... }
            </code>
            message handler methods can be static or instance methods.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseService.AddMessageHandlerAsync``1(System.String,Friflo.Json.Fliox.Hub.Host.HostMessageHandlerAsync{``0})">
            <summary>
            Add an asynchronous message handler method with a method signature like:
            <code>
            Task TestMessage(Param&lt;TestCommand&gt; param, MessageContext context) { ... }
            </code>
            message handler methods can be static or instance methods.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseService.AddCommandHandler``2(System.String,Friflo.Json.Fliox.Hub.Host.HostCommandHandler{``0,``1})">
            <summary>
            Add a synchronous command handler method with a method signature like:
            <code>
            bool TestCommand(Param&lt;TestCommand&gt; param, MessageContext context) { ... }
            </code>
            command handler methods can be static or instance methods.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseService.AddCommandHandlerAsync``2(System.String,Friflo.Json.Fliox.Hub.Host.HostCommandHandlerAsync{``0,``1})">
            <summary>
            Add an asynchronous command handler method with a method signature like:
            <code>
            Task&lt;bool&gt; TestCommand(Param&lt;TestCommand&gt; param, MessageContext context) { ... }
            </code>
            command handler methods can be static or instance methods.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseService.AddMessageHandlers(System.Object,System.String)">
            <summary>
            Add all methods of the given class <paramref name="commands"/> with the parameters <br/>
            (<see cref="T:Friflo.Json.Fliox.Hub.Host.Param`1"/> param, <see cref="T:Friflo.Json.Fliox.Hub.Host.MessageContext"/> context) as a message/command handler. <br/>
            A command handler has return type - a message handler returns void. <br/>
            Command handler example:
            <code>
            bool TestCommand(Param&lt;TestCommand&gt; param, MessageContext context) { ... }
            </code>
            Message handler methods can be: <br/>
            - static or instance methods <br/>
            - synchronous or asynchronous - using <see cref="T:System.Threading.Tasks.Task`1"/> as return type.
            </summary>
            <param name="commands">the instance of class containing message handler methods.
                Commonly the instance of a <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseService"/></param>
            <param name="messagePrefix">the prefix of a message/command - e.g. "test."; null or "" to add messages without prefix</param>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseService.TransactionBeginAsync(Friflo.Json.Fliox.Hub.Host.Param{Friflo.Json.Fliox.Hub.Host.Auth.Empty},Friflo.Json.Fliox.Hub.Host.MessageContext)">
            <summary>
            The returned result will be exchanged by <see cref="M:Friflo.Json.Fliox.Hub.Host.SyncContext.UpdateTransactionBeginResult(System.Int32,Friflo.Json.Fliox.Hub.Host.SQL.TransResult)"/>
            after execution of Begin or Rollback.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseService.Client(Friflo.Json.Fliox.Hub.Host.Param{Friflo.Json.Fliox.Hub.DB.Cluster.ClientParam},Friflo.Json.Fliox.Hub.Host.MessageContext)">
            <summary>
            Calling <see cref="M:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.SendUnacknowledgedEvents"/> here is too early.
            An outdated <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.eventReceiver"/> may be used.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Std">
            Should not be public. commands are prefix with
            <b>std.*</b>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue"/> can be used by a <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseService"/> to queue execution
            of all commands and messages.<br/>
            <br/>
            To execute queued commands the application needs to call <see cref="M:Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue.ExecuteQueuedRequestsAsync"/> on a regular basis.<br/>
            This enables synchronous execution of requests / commands / tasks  on the <b>main thread used in game loops</b>.<br/>
            As a result states or resources used / mutated by commands can be performed without any expensive thread synchronization mechanisms.<br/>
            <br/>
            <b>Note</b>: <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue"/> is not appropriate for a typical server application as they are not intended
            to have a 'main thread' which would be the bottle neck for high concurrency.   
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue.ExecuteQueuedRequestsAsync">
            <summary>
            Execute queued requests in case request queueing is enabled in the <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseService"/> constructor
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue.ExecuteQueuedRequests(Friflo.Json.Fliox.Hub.Host.AsyncServiceJobs@)">
            <summary>
            Execute queued requests which can be executed synchronous. <br/>
            Return all requests which require asynchronous execution in <paramref name="asyncServiceJobs"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue.ExecuteQueuedRequestsAsync(Friflo.Json.Fliox.Hub.Host.AsyncServiceJobs)">
            <summary>
            Execute requests returned from <see cref="M:Friflo.Json.Fliox.Hub.Host.DatabaseServiceQueue.ExecuteQueuedRequests(Friflo.Json.Fliox.Hub.Host.AsyncServiceJobs@)"/> which require asynchronous execution.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.EntityContainer">
            <summary>
            An <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> is the abstraction of a collection / table used to store entities / records 
            as key value pairs.
            </summary>
            <remarks>
            It uses a string as key and a JSON object as value. Each container is intended to store the
            entities / records of a specific type. E.g. one container for storing JSON objects representing 'articles'
            another one for storing 'orders'.
            <para>
              <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> define the entire set of interfaces a database adapter needs to implement to
              enable the complete feature set of <see cref="T:Friflo.Json.Fliox.Hub.Client.EntitySet`2"/> and <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>.
              <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> and all its implementations must be thread safe.
            </para>
            <para>
              The interface methods are designed to enable clear, compact and efficient implementations of database
              operations. E.g. operations like SELECT, INSERT, DELETE or UPDATE in case of an SQL database adapter.
              <see cref="T:Friflo.Json.Fliox.Hub.Host.MemoryContainer"/>, <see cref="T:Friflo.Json.Fliox.Hub.Host.FileContainer"/> and <c>CosmosContainer</c> show straight forward
              implementation of <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/>.
              Additional to memory implementation <see cref="T:Friflo.Json.Fliox.Hub.Host.FileContainer"/> shows also how to handle database errors.
              These errors fall into two categories:
              <para>1. A complete database request fails. E.g. a SELECT in SQL.
                    => <see cref="P:Friflo.Json.Fliox.Hub.Protocol.Models.ITaskResultError.Error"/> need to be set.
              </para> 
              <para>2. The database request was successful, but one or more entities (key/values) had an error when accessing.
                    E.g. Writing an entity to a file with a <see cref="T:Friflo.Json.Fliox.Hub.Host.FileContainer"/> fails because it is used by another process.
                    => An <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.EntityError"/> need to be added to task result errors.
                       E.g. add an error to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntitiesResult.errors"/> in case of
                       <see cref="M:Friflo.Json.Fliox.Hub.Host.FileContainer.CreateEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
              </para>
              
              All ...Result types returned by the interface methods of <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> like
              <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.CreateEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>, <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.ReadEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>, ... implement <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.ITaskResultError"/>.
              In case a database command fails completely  <see cref="P:Friflo.Json.Fliox.Hub.Protocol.Models.ITaskResultError.Error"/> needs to be set.
              See <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> for proper error handling.
            </para>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.EntityContainer.name">
            <summary> container name </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.EntityContainer.instanceName">
            <summary>
            The name used for a container / table instance in a specific database. By default it is equal to <see cref="F:Friflo.Json.Fliox.Hub.Host.EntityContainer.name"/>.
            It can be customized (altered) by the <see cref="P:Friflo.Json.Fliox.Hub.Host.EntityDatabase.CustomContainerName"/> function.
            This field need to be used for <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> implementations when accessing a specific
            databases (e.g. Mongo, Dynamo, Cosmos, Postgres, ...).
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.CreateEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Create the entities specified in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.UpsertEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Upsert the entities specified in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.ReadEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Read entities by id with the ids passed in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.DeleteEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Delete entities by id with the ids passed in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.QueryEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Query entities using the filter in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.AggregateEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Performs an aggregation specified in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.UpsertEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Upsert the entities specified in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.ReadEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Read entities by id with the ids passed in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.DeleteEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Delete entities by id with the ids passed in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.QueryEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Query entities using the filter in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.AggregateEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>Performs an aggregation specified in the given <paramref name="command"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.StoreCursor(Friflo.Json.Fliox.Hub.Host.Utils.QueryEnumerator,Friflo.Json.Fliox.Hub.Host.Auth.User)">
            <summary>
            Create and return a unique cursor id and store the given <paramref name="enumerator"/> with this id.<br/>
            The cursor id created by a previous call for the given <paramref name="enumerator"/> will be removed.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.RemoveCursor(Friflo.Json.Fliox.Hub.Host.Utils.QueryEnumerator)">
            <summary>
            Remove the given <paramref name="enumerator"/> from stored cursors.<br/>
            The given <paramref name="enumerator"/> can be null.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.FindCursor(System.String,Friflo.Json.Fliox.Hub.Host.SyncContext,Friflo.Json.Fliox.Hub.Host.Utils.QueryEnumerator@,Friflo.Json.Fliox.Hub.Protocol.Models.TaskExecuteError@)">
            <summary>
            Find the enumerator for the given <paramref name="cursor"/> id.<br/>
            Return true if the <paramref name="cursor"/> was found. Otherwise false.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.MergeEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
             <summary>Apply the given <paramref name="mergeEntities"/> to the container entities</summary>
             <remarks>
             Default implementation to apply patches to entities.
             The implementation perform three steps:
             1. Read entities to be patches from a database
             2. Apply merge patches
             3. Write back the merged entities
            
             If the used database has integrated support for merging (patching) JSON its <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/>
             implementation can override this method to replace two database requests by one.<br/>
             <br/>
             Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.MergeEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
             </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.CountEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Default implementation. Performs a full table scan! Act as reference and is okay for small data sets.<br/>
            Counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.CountEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.ReadReferencesAsync(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.References},Friflo.Json.Fliox.Hub.Protocol.Models.Entities,Friflo.Json.Fliox.ShortString,System.String,Friflo.Json.Fliox.Hub.Host.SyncContext)">
             <summary>
             Return the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.ReferencesResult.entities"/> referenced by the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.References.selector"/> path
             of the given <paramref name="entities"/>.<br/>
            
             Counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.ReadReferences(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.References},Friflo.Json.Fliox.Hub.Protocol.Models.Entities,Friflo.Json.Fliox.ShortString,System.String,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
             </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.MergeEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
             <summary>Apply the given <paramref name="mergeEntities"/> to the container entities</summary>
             <remarks>
             Default implementation to apply patches to entities.
             The implementation perform three steps:
             1. Read entities to be patches from a database
             2. Apply merge patches
             3. Write back the merged entities
            
             If the used database has integrated support for merging (patching) JSON its <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/>
             implementation can override this method to replace two database requests by one.<br/>
             <br/>
             Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.MergeEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
             </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.CountEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Default implementation. Performs a full table scan! Act as reference and is okay for small data sets.<br/>
            Counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.CountEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.ReadReferences(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.References},Friflo.Json.Fliox.Hub.Protocol.Models.Entities,Friflo.Json.Fliox.ShortString,System.String,Friflo.Json.Fliox.Hub.Host.SyncContext)">
             <summary>
             Return the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.ReferencesResult.entities"/> referenced by the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.References.selector"/> path
             of the given <paramref name="entities"/>.<br/>
            
             Counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.ReadReferencesAsync(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.References},Friflo.Json.Fliox.Hub.Protocol.Models.Entities,Friflo.Json.Fliox.ShortString,System.String,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
             </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityContainerUtils.GetReferences(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.References},Friflo.Json.Fliox.Hub.Protocol.Models.Entities@,Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Return the ids - foreign keys - stored in the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.References.selector"/> fields
            of the given <paramref name="entities"/>.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.ReadReferencesResult">
            <see cref="T:Friflo.Json.Fliox.Hub.Host.ReadReferencesResult"/> is never serialized within a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse"/> only its
            fields <see cref="F:Friflo.Json.Fliox.Hub.Host.ReadReferencesResult.references"/>.
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.TableType">
            <summary>Specify the column schema of an SQL table</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.TableType.JsonColumn">
            <summary>store a document in a single JSON column</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.TableType.Relational">
            <summary>store each member of a document in a separate typed column</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Setup">
            <summary>
            A set of options used in <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.SetupDatabaseAsync(Friflo.Json.Fliox.Hub.Host.Setup)"/><br/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Setup.CreateDatabase">
            <summary>Create a database if not exists</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Setup.CreateTables">
            <summary>Create all tables missing in the database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Setup.AddVirtualColumns">
            <summary>Create missing virtual - computed - columns for a database with <see cref="F:Friflo.Json.Fliox.Hub.Host.TableType.JsonColumn"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Setup.AddColumns">
            <summary>Create missing columns for a database with <see cref="F:Friflo.Json.Fliox.Hub.Host.TableType.JsonColumn"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> is the abstraction for specific database adapter / implementation e.g. a
            <see cref="T:Friflo.Json.Fliox.Hub.Host.MemoryDatabase"/> or <see cref="T:Friflo.Json.Fliox.Hub.Host.FileDatabase"/>.
            </summary>
            <remarks>
            An <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> contains multiple <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/>'s each representing
            a table / collection of a database. Each container is intended to store the records / entities of a specific type.
            E.g. one container for storing JSON objects representing 'articles' another one for storing 'orders'.
            <br/>
            Optionally a <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/> can be assigned to the database via the property <see cref="P:Friflo.Json.Fliox.Hub.Host.EntityDatabase.Schema"/>.
            This enables Type / schema validation of JSON entities written (create, update and patch) to its containers.
            <br/>
            Instances of <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> and all its implementation are designed to be thread safe enabling multiple
            clients e.g. <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> operating on the same <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> instance
            - used by a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/>.
            To maintain thread safety <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> implementations must not have any mutable state.
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.EntityDatabase.name">
            <summary>database name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.EntityDatabase.nameShort">
            <summary>database name encoded as type <see cref="T:Friflo.Json.Fliox.ShortString"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.EntityDatabase.containers">
            <summary> map of of containers identified by their container name </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.EntityDatabase.Schema">
            <summary>
            An optional <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/> used to validate the JSON payloads in all write operations
            performed on the <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/>'s of the database
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.EntityDatabase.CustomContainerName">
            <summary>A mapping function used to assign a custom container name.</summary>
            <remarks>
            If using a custom name its value is assigned to the containers <see cref="F:Friflo.Json.Fliox.Hub.Host.EntityContainer.instanceName"/>. 
            By having the mapping function in <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> it enables uniform mapping across different
            <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> implementations.
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.EntityDatabase.service">
            <summary>
            The <see cref="F:Friflo.Json.Fliox.Hub.Host.EntityDatabase.service"/> execute all <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> send by a client.
            An <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> implementation can assign as custom handler by its constructor
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.EntityDatabase.StorageType">
            <summary>name of the storage type. E.g. <c>in-memory, file-system, remote, Cosmos, ...</c></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.#ctor(System.String,Friflo.Json.Fliox.Hub.Host.DatabaseSchema,Friflo.Json.Fliox.Hub.Host.DatabaseService)">
            <summary>
            constructor parameters are mandatory to force implementations having them in their constructors also or
            pass null by implementations.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.SetupDatabaseAsync(Friflo.Json.Fliox.Hub.Host.Setup)">
            <summary>
            Create a ready-to-use database or modify the schema of an existing database.<br/>
            <br/>
            <b>Note:</b> This method is intended for development to create a database and update its tables based on its <see cref="P:Friflo.Json.Fliox.Hub.Host.EntityDatabase.Schema"/>.<br/>
            In a production environment this method should be called from a migration script - not from a service.
            </summary>
            <remarks>
            <i>Note</i>: <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.SetupDatabaseAsync(Friflo.Json.Fliox.Hub.Host.Setup)"/> support only additive database operations to prevent data loss.<br/>
            Dropping tables or columns need to be done with appropriate database tools.<br/>
            <br/> 
            The parameter <paramref name="options"/> define which database operations are executed.
            <list type="bullet">
                <item>Create a database if not exist</item>
                <item>Create tables which not exist</item>
                <item>Add missing virtual columns if using a database with <see cref="F:Friflo.Json.Fliox.Hub.Host.TableType.JsonColumn"/> tables</item>
                <item>Add missing columns if using a database with <see cref="F:Friflo.Json.Fliox.Hub.Host.TableType.Relational"/> tables</item>
            </list>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.IsSyncTask(Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask,Friflo.Json.Fliox.Hub.Protocol.Tasks.PreExecute@)">
            <summary>
            return true to execute given <paramref name="task"/> synchronous. <br/>
            return false to execute the <paramref name="task"/> asynchronous
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.CreateContainer(Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.Hub.Host.EntityDatabase)">
            <summary>Create a container with the given <paramref name="name"/> in the database</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.GetOrCreateContainer(Friflo.Json.Fliox.ShortString@)">
            <summary>
            return the <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> with the given <paramref name="name"/>.
            Create a new <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> if not already done.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.GetDbContainers(System.String,Friflo.Json.Fliox.Hub.Host.FlioxHub)">
            <summary>return all database containers</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.GetDbMessages">
            <summary>return all database messages and commands</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.SeedDatabase(Friflo.Json.Fliox.Hub.Host.EntityDatabase,System.Nullable{System.Int32})">
            <summary>Seed the database with content of the given <paramref name="src"/> database</summary>
            <remarks>
            If given database has no schema the key name of all entities in all containers need to be "id"
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.EntityFilterContext">
            Default implementation. Performs a full table scan! Act as reference and is okay for small data sets
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.FileDatabase">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.FileDatabase"/> is used to store the entities / records of its containers as <b>JSON</b>
            files in the <b>file-system</b>.
            </summary>
            <remarks>
            Each database container / table is a sub folder of the path passed to the <see cref="T:Friflo.Json.Fliox.Hub.Host.FileDatabase"/> constructor.<br/>
            The intention of a <see cref="T:Friflo.Json.Fliox.Hub.Host.FileDatabase"/> is providing <b>out of the box</b> persistence without the need of
            installation or configuration of a third party database server like: SQLite, Postgres, ...<br/>
            This enables the following uses cases
            <list type="bullet">
              <item>Creating <b>proof-of-concept</b> database applications without any third party dependencies</item>
              <item>Suitable for <b>TDD</b> as test records are JSON files versioned via Git and providing access to their change history</item>
              <item>Using a database <b>without configuration</b> by using a relative database path within a project</item>
              <item>Viewing and editing database records as JSON files with <b>text editors</b> like VSCode, vi, web browsers, ...<br/></item>
              <item>Using a <see cref="T:Friflo.Json.Fliox.Hub.Host.FileDatabase"/> as data source to <b>seed</b> other databases with <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.SeedDatabase(Friflo.Json.Fliox.Hub.Host.EntityDatabase,System.Nullable{System.Int32})"/></item>
            </list>
            In most uses cases a <see cref="T:Friflo.Json.Fliox.Hub.Host.FileDatabase"/> in not suitable for production as its read / write performance
            cannot compete with databases like: SQLite, Postgres, ... . <br/>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.FileDatabase"/> has no third party dependencies.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FileUtils.WriteText(System.String,Friflo.Json.Fliox.JsonValue,System.IO.FileMode)">
            <summary>
            Write with <see cref="F:System.IO.FileShare.Read"/> as on a developer machine other processes like virus scanner or file watcher
            may access the file concurrently resulting in:
            IOException: The process cannot access the file 'path' because it is being used by another process
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.FlioxHub">
             <summary>
             A <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> act as a Proxy between a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> or a web browser and an <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/>.
             </summary>
             <remarks>
             The <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> features and utilization is available at
             <a href="https://github.com/friflo/Friflo.Json.Fliox/blob/main/Json/Fliox.Hub/Host/README.md#flioxhub">Host README.md</a>
            
             When creating a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> a <b>default <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/></b> is assigned to the instance
             and all tasks requested by a client are applied to this <see cref="F:Friflo.Json.Fliox.Hub.Host.FlioxHub.database"/>. <br/>
             A <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> can be configured to support:
             <list type="bullet">
               <item>
                 <b>Pub-Sub</b> to send events of database changes or messages to clients by assigning an
                 <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher"/> to <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.EventDispatcher"/>. <br/>
                 Note: A client need to subscribe events in order to receive them. 
               </item>
               <item>
                 <b>User authentication</b> and <b>task authorization</b>. Each task is authorized individually. <br/>
                 To enable this assign a <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator"/> to <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.Authenticator"/>.
               </item>
               <item>
                 <b>Monitoring</b> of database access (requests) by adding a <see cref="T:Friflo.Json.Fliox.Hub.DB.Monitor.MonitorDB"/> with
                 <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.AddExtensionDB(Friflo.Json.Fliox.Hub.Host.EntityDatabase)"/>.
               </item>
             </list>
             A <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> instance handle <b>all</b> client requests by its <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> method. <br/>
             A request is represented by a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> and its <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> are executed
             on the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.database"/>. <br/>
             If database == null the default <see cref="F:Friflo.Json.Fliox.Hub.Host.FlioxHub.database"/> of <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> is used.
             <br/>
             The <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> contains all database operations like create, read, upsert, delete
             and all messages / commands send by a client. <br/>
             The <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> execute these tasks by the <see cref="F:Friflo.Json.Fliox.Hub.Host.EntityDatabase.service"/> of the
             specified <see cref="F:Friflo.Json.Fliox.Hub.Host.FlioxHub.database"/>.<br/>
             <br/>
             Instances of <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> are <b>thread-safe</b> enabling multiple clients e.g. <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>
             operating on the same <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> instance. <br/>
             To maintain thread safety <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> implementations must not have any mutable state.
             </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)">
             <summary>
             Execute all <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> send by client.<br/>
             Method is thread-safe as multiple <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> instances are allowed to
             use a single <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> instance.
             </summary>
             <remarks>
             All requests to a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> are handled by this method.
             By design this is the 'front door' all requests have to pass to get processed.
             <para>
               <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> catches exceptions thrown by a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/> but 
               this is only a fail safe mechanism.
               Thrown exceptions need to be handled by proper error handling in the first place.
            
               Reasons for the design decision: 
               <para> a) Without a proper error handling the root cause of an error cannot be traced back.</para>
               <para> b) Exceptions are expensive regarding CPU utilization and heap allocation.</para>
             </para>
             <para>
               An exception can have two different reasons:
               <para> 1. The implementation of an <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> is missing a proper error handling.
                      A proper error handling requires to set a meaningful <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.TaskExecuteError"/> to
                      <see cref="P:Friflo.Json.Fliox.Hub.Protocol.Models.ITaskResultError.Error"/></para>
               <para> 2. An issue in the namespace <see cref="N:Friflo.Json.Fliox.Hub.Protocol"/> which must to be fixed.</para> 
             </para>
             </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequest(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)">
             <summary>
             Execute all <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> send by client.
             </summary>
             <remarks>
             All requests to a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> are handled by this method.
             By design this is the 'front door' all requests have to pass to get processed.
             <para>
               <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> catches exceptions thrown by a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/> but 
               this is only a fail safe mechanism.
               Thrown exceptions need to be handled by proper error handling in the first place.
            
               Reasons for the design decision: 
               <para> a) Without a proper error handling the root cause of an error cannot be traced back.</para>
               <para> b) Exceptions are expensive regarding CPU utilization and heap allocation.</para>
             </para>
             <para>
               An exception can have two different reasons:
               <para> 1. The implementation of an <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> is missing a proper error handling.
                      A proper error handling requires to set a meaningful <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.TaskExecuteError"/> to
                      <see cref="P:Friflo.Json.Fliox.Hub.Protocol.Models.ITaskResultError.Error"/></para>
               <para> 2. An issue in the namespace <see cref="N:Friflo.Json.Fliox.Hub.Protocol"/> which must to be fixed.</para> 
             </para>
             </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.FlioxHub.database">
            <summary> The default <see cref="F:Friflo.Json.Fliox.Hub.Host.FlioxHub.database"/> assigned to the <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.EventDispatcher">
            <summary>
            An optional <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher"/> used to enable Pub-Sub. <br/>
            If assigned the database send push events to clients for database changes and messages these clients have subscribed.
            </summary>
            <remarks>
            In case of remote database connections <b>WebSockets</b> are used to send Pub-Sub events to clients.   
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.Authenticator">
            <summary>
            An <see cref="T:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator"/> performs authentication and authorization for all
            <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> in a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> sent by a client.
            All successful authorized <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> are executed by the <see cref="F:Friflo.Json.Fliox.Hub.Host.EntityDatabase.service"/>.
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.ClientController">
            <summary>
            <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.ClientController"/> is used to create / add unique client ids to enable sending events to
            specific user clients.
            It also enables monitoring execution statistics of <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> 
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.HostName">
            <summary>
            On server side the name can be used to identify a specific host if used within a cluster of servers.<br/>
            On client side any name can be assigned to simplify differentiation if using multiple <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> instances.
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.HostVersion">
            <summary>host <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.HostVersion"/> - available via command <b>std.Host</b></summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.Info">
            <summary>General descriptive Hub information - available via command <b>std.Host</b></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.CreateDefaultAuthenticator">
            <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.Authenticator"/> is mutable => create new instance per Hub 
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.#ctor(Friflo.Json.Fliox.Hub.Host.EntityDatabase,Friflo.Json.Fliox.Hub.Host.SharedEnv)">
            <summary>
            Construct a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> with the given default <paramref name="database"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.SetupDatabasesAsync(Friflo.Json.Fliox.Hub.Host.Setup)">
            <summary>
            Utility methods calling <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.SetupDatabaseAsync(Friflo.Json.Fliox.Hub.Host.Setup)"/> for the main and extension databases.<br/>
            <b>Note:</b> This method is intended for use during development. See docs at <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.SetupDatabaseAsync(Friflo.Json.Fliox.Hub.Host.Setup)"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.GetResponseReaderPool">
            <summary>
            Optimization for Unity to avoid heap allocations of <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse"/> instances and its dependencies
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.InitSyncRequest(Friflo.Json.Fliox.Hub.Protocol.SyncRequest)">
            <summary>
            Before execution of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> with <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> or <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequest(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> 
            the <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> must be initialized. <br/>
            If the request can be executed synchronously the method returns <see cref="F:Friflo.Json.Fliox.Hub.Host.ExecutionType.Sync"/><br/>
            Doing so avoids creation of a redundant <see cref="T:System.Threading.Tasks.Task"/> instance.  
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.PostExecute(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Protocol.SyncResponse,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Execute at the end of <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> and <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequest(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.AddExtensionDB(Friflo.Json.Fliox.Hub.Host.EntityDatabase)">
            <summary>
            Add an <paramref name="extensionDB"/> to the Hub. The extension database is identified by its
            <see cref="F:Friflo.Json.Fliox.Hub.Host.EntityDatabase.nameShort"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.HubInfo">
            <summary>
            Contains general information about a Hub describing the development environment. <br/>
            Clients can request this information with the command <b>std.Details</b>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.HubInfo.projectName">
            <summary>project name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.HubInfo.envName">
            <summary>environment name. E.g. dev, tst, stg, prd</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.HubInfo.projectWebsite">
            <summary>project website url</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.HubInfo.envColor">
            <summary>
            the color used to display the environment name in GUI's using CSS color format.<br/>
            E.g. using red for a production environment: "#ff0000" or "rgb(255 0 0)"
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.MemoryContainer.MergeEntities(Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary> Optimized merge implementation specific for <see cref="T:Friflo.Json.Fliox.Hub.Host.MemoryContainer"/> </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.MemoryDatabase">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.MemoryDatabase"/> is a non-persistent database used to store records in memory.
            </summary>
            <remarks>
            The intention is having a shared database which can be used in high performance scenarios. E.g:<br/>
            4 Core i7-4790K CPU 4.00GHz: 1.000.000 requests / second. <br/>
            Mac Mini M2:                 1.800.000 requests / second. <br/>
            Following use-cases are suitable for a <see cref="T:Friflo.Json.Fliox.Hub.Host.MemoryDatabase"/>
            <list type="bullet">
              <item>Run a big amount of unit tests fast and efficient as instantiation of <see cref="T:Friflo.Json.Fliox.Hub.Host.MemoryDatabase"/> take only some micro seconds. </item>
              <item>Use as a Game Session database for online multiplayer games as it provide sub millisecond response latency</item>
              <item>Use as test database for <b>TDD</b> without any configuration </item>
              <item>Is the benchmark reference for all other database implementations regarding throughput and latency</item>
            </list>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.MemoryDatabase"/> has no third party dependencies.
            <i>Storage characteristics</i> <br/>
            <b>Keys</b> are stored as <see cref="T:Friflo.Json.Fliox.JsonKey"/> - keys that can be converted to <see cref="T:System.Int64"/> or <see cref="T:System.Guid"/>
            are stored without heap allocation. Otherwise a <see cref="T:System.String"/> is allocated <br/>
            <b>Values</b> are stored as <see cref="T:Friflo.Json.Fliox.JsonValue"/> - essentially a <see cref="T:System.Byte"/>[]
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.MemoryDatabase.SmallValueSize">
            <summary>Intended for write heavy containers.</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.MemoryDatabase.#ctor(System.String,Friflo.Json.Fliox.Hub.Host.DatabaseSchema,Friflo.Json.Fliox.Hub.Host.DatabaseService)">
            Byte arrays used to store container values are reused in case their length is less or equal this size. 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.MemoryType.NonConcurrent">
            used to preserve insertion order of entities in ClusterDB and MonitorDB
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.RemoteEventMessage">
            <summary> Reflect the shape of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteEventMessage.msg">
            map to <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolEvent"/> discriminator 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteEventMessage.clt">
            map to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolEvent.dstClientId"/> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteEventMessage.seq">
            map to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.EventMessage.seq"/> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteEventMessage.ev">
            map to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.EventMessage.events"/> 
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.RemoteSyncEvent">
            <summary> Reflect the shape of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteSyncEvent.usr">
            map to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.usr"/> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteSyncEvent.db">
            map to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.db"/> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteSyncEvent.clt">
            map to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.clt"/> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteSyncEvent.tasks">
            map to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasks"/> 
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.RemoteMessageTask">
            <summary> Reflect the shape of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteMessageTask.task">
            map to <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask"/> discriminator
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteMessageTask.name">
            map to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.name"/> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.RemoteMessageTask.param">
            map to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.param"/> 
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.MessageUtils">
            <summary>
            <b>Attention</b> all <c>Create</c> methods return a <see cref="T:Friflo.Json.Fliox.JsonValue"/> which are only valid until the
            passed <see cref="T:Friflo.Json.Fliox.Mapper.ObjectReader"/> it reused 
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.MessageUtils.WriteProtocolMessage(Friflo.Json.Fliox.Hub.Protocol.ProtocolMessage,Friflo.Json.Fliox.Hub.Host.SharedEnv,Friflo.Json.Fliox.Mapper.ObjectWriter)">
            <summary>
            <b>Attention</b> returned <see cref="T:Friflo.Json.Fliox.JsonValue"/> is <b>only</b> valid until the passed <paramref name="writer"/> is reused
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.MessageUtils.WriteEventMessage(System.Collections.Generic.List{Friflo.Json.Fliox.JsonValue},Friflo.Json.Fliox.ShortString@,System.Int32,Friflo.Json.Fliox.Mapper.ObjectWriter)">
            <summary>
            Creates a serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/><br/>
            <b>Attention</b> returned <see cref="T:Friflo.Json.Fliox.JsonValue"/> is <b>only</b> valid until the passed <paramref name="writer"/> is reused
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.MessageUtils.WriteSyncTask(Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask,Friflo.Json.Fliox.Mapper.ObjectWriter)">
            <summary>
            <b>Attention</b> returned <see cref="T:Friflo.Json.Fliox.JsonValue"/> is <b>only</b> valid until the passed <paramref name="writer"/> in  is reused
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.MessageUtils.WriteSyncEvent(Friflo.Json.Fliox.Hub.Protocol.SyncEvent@,Friflo.Json.Fliox.Mapper.ObjectWriter)">
            <summary>
            <b>Attention</b> returned <see cref="T:Friflo.Json.Fliox.JsonValue"/> is <b>only</b> valid until the passed <paramref name="writer"/> in  is reused
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.MessageUtils.ReadMessageHead(Friflo.Json.Burst.Utf8JsonParser@,Friflo.Json.Fliox.JsonValue@)">
            <summary>
            Parse the header of the given <paramref name="rawMessage"/> object.<br/>
            The returned <see cref="F:Friflo.Json.Fliox.Hub.Host.MessageHead.type"/> enables the caller further processing.<br/>
            Parsing stops when the required members are read.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.NamespaceDoc">
            <summary>
            Contains the <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> used to provide access to <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/>'s.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Pool">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Pool"/> is a set of pooled instances of various <see cref="M:Friflo.Json.Fliox.Hub.Host.Pool.Type``1(System.Func{``0})"/>'s.
            To enable pooling instances of a specific class it needs to implement <see cref="T:System.IDisposable"/>.
            Pool for classes used commonly within <see cref="N:Friflo.Json.Fliox.Hub.Host"/> are directly available. E.g. <see cref="P:Friflo.Json.Fliox.Hub.Host.Pool.ObjectMapper"/>.
            Custom types can also be managed by <see cref="T:Friflo.Json.Fliox.Hub.Host.Pool"/> by using <see cref="M:Friflo.Json.Fliox.Hub.Host.Pool.Type``1(System.Func{``0})"/>.
            Its typical use case is pooling a domain specific <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> implementation. 
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Pool.ObjectMapper">
            <summary> Returned <see cref="T:Friflo.Json.Fliox.Mapper.ObjectMapper"/> doesn't throw Read() exceptions. To handle errors its
            <see cref="F:Friflo.Json.Fliox.Mapper.ObjectMapper.reader"/> -> <see cref="P:Friflo.Json.Fliox.Mapper.ObjectReader.Error"/> need to be checked. </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Pool.Type``1(System.Func{``0})">
            <summary>
            Enable pooling instances of the given Type <typeparamref name="T"/>. In case no cached instance of <typeparamref name="T"/>
            is available the <paramref name="factory"/> method is called to create a new instance.
            After returning a pooled instance to its pool with <see cref="M:Friflo.Json.Fliox.Utils.ObjectPool`1.Return(`0)"/> it is cached and
            will be reused when calling <see cref="M:Friflo.Json.Fliox.Utils.ObjectPool`1.Get"/> anytime later.
            To ensure pooled instances are not leaking use the using directive. E.g.
            <code>
            using (var pooledMapper = syncContext.pool.ObjectMapper.Get()) {
                ...
            }
            </code>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.SharedEnv">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.SharedEnv"/> provide a set of shared resources available via <see cref="F:Friflo.Json.Fliox.Hub.Host.FlioxHub.sharedEnv"/>.
            </summary>
            <remarks>
            In particular it provides a <see cref="P:Friflo.Json.Fliox.Hub.Host.SharedEnv.TypeStore"/> and a <see cref="T:Friflo.Json.Fliox.Hub.Host.Pool"/>.
            The resources contained by a <see cref="T:Friflo.Json.Fliox.Hub.Host.SharedEnv"/> are designed for being reused to avoid expensive
            heap allocations when required.
            The intention is to use only a single <see cref="T:Friflo.Json.Fliox.Hub.Host.SharedEnv"/> instance within the whole application.
            <br/>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.SharedEnv"/> references are passed as a parameter to every <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> constructor.
            If null it defaults to the <see cref="P:Friflo.Json.Fliox.Hub.Host.SharedEnv.Default"/> <see cref="T:Friflo.Json.Fliox.Hub.Host.SharedEnv"/> instance.
            If an application needs to control the lifecycle of all shared resources it needs to create its own
            <see cref="M:Friflo.Json.Fliox.Hub.Host.SharedEnv.#ctor"/> instance and pass it to the constructor to all <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> instances it creates.
            <br/>
            Access to shared resources is thread safe.
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.SharedEnv.Default">
            <summary>Set breakpoint to check if <see cref="F:Friflo.Json.Fliox.Hub.Host.SharedEnv.DefaultSharedEnv"/> is used </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SharedEnv.DisposePool">
            obsolete - TODO remove
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.SharedCache">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.SharedCache"/> is a cache for shared instances directly or indirectly used by
            <see cref="T:Friflo.Json.Fliox.Hub.Host.HostCommandHandler`2"/> or <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/> methods. <br/>
            Cached instances created and returned by <see cref="T:Friflo.Json.Fliox.Hub.Host.SharedCache"/> must me immutable to enable
            concurrent and / or parallel usage.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SharedCache.GetValidationType(System.Type)">
            <summary> Return an immutable <see cref="T:Friflo.Json.Fliox.Schema.Validation.ValidationType"/> instance for the given <param name="type"></param></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.SyncContext">
            <summary>
            One <see cref="T:Friflo.Json.Fliox.Hub.Host.SyncContext"/> is created per <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> call to enable
            multi threaded / concurrent handling of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>.
            </summary>
            <remarks>
            Note: In case of adding transaction support for <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>'s in future transaction data / state
            need to be handled by this class.
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.SyncContext.pool">
            <summary>
            Note!  Keep <see cref="F:Friflo.Json.Fliox.Hub.Host.SyncContext.pool"/> internal
            Its <see cref="T:Friflo.Json.Fliox.Utils.ObjectPool`1"/> instances can be made public as properties if required
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.SyncContext.eventReceiver">
            <summary>Is set for clients requests only. In other words - from the initiator of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SyncContext.#ctor(Friflo.Json.Fliox.Hub.Host.SharedEnv,Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver,Friflo.Json.Fliox.Hub.Host.SyncBuffers@,Friflo.Json.Fliox.Hub.Host.SyncPools)">
            <summary>Special constructor used to minimize heap allocation. <b>Note</b> <see cref="T:Friflo.Json.Fliox.Hub.Host.SyncBuffers"/> </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.SyncBuffers">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.SyncBuffers"/> can be used to minimize heap allocations by passing to <see cref="T:Friflo.Json.Fliox.Hub.Host.SyncContext"/> constructor. <br/>
            <b>Note</b> The the caller of <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> <b>must</b> ensure that only one call to
            <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> is running at a time.<br/>
            This requirement is fulfilled if request execution is stream based like <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSocketHost"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.ExecuteSyncResult">
            <summary>
            Contains the result of a <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> call. <br/>
            After execution either <see cref="F:Friflo.Json.Fliox.Hub.Host.ExecuteSyncResult.success"/> or <see cref="F:Friflo.Json.Fliox.Hub.Host.ExecuteSyncResult.error"/> is set. Never both.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.ExecutionType">
            <summary> Defines how to execute a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> </summary>
            <remarks>
            It is used to
            <list type="bullet">
              <item>
                Execute a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> with a synchronous call if possible to avoid heap allocation
                and CPU costs required for asynchronous methods if possible.<br/>
                Also the stacktrace of synchronous calls are smaller - one level instead of three for async calls -
                are easier to read. 
              </item>
              <item>
                Enable queued execution of <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>. See <see cref="F:Friflo.Json.Fliox.Hub.Host.DatabaseService.queue"/>
              </item>
            </list>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.ExecutionType.Error">
            <summary>execute request error synchronous with <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequest(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.ExecutionType.Sync">
            <summary>execute request synchronous with <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequest(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.ExecutionType.Async">
            <summary>execute request asynchronous with <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.ExecutionType.Queue">
            <summary>queue request execution with <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.QueueRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/> can be assigned to a <see cref="P:Friflo.Json.Fliox.Hub.Host.EntityDatabase.Schema"/> to enable validation
            of entities represented as JSON used in write operations - create, upsert and patch.
            </summary>
            <remarks>
            It is intended to be used for <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/> instances to ensure that the entities
            (records) in an <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> always meet the expected type. So only successful validated JSON
            payloads are written to an <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/>.
            JSON validation includes the following checks:
            <list type="bullet">
              <item>
                Check if the type of a property matches the container entity type.<br/>
                E.g. A container using a type 'Article' expect the property "name" of type string.
                <code>{ "id": "test", "name": 123 }</code> will result in the error:
                <code>WriteError: Article 'test', Incorrect type. was: 123, expect: string at Article > name</code>
              </item>
              <item>
                Check if required properties defined in the container type are present in the JSON payload.<br/>
                E.g. A container using a type 'Article' requires the property "name" being present.
                <code>{ "id": "test" }</code> will result in the error:
                <code>WriteError: Article 'test', Missing required fields: [name] at Article > (root)</code>
              </item>
              <item>
                Check that no unknown properties are present in a JSON payload<br/>
                E.g. A container using a type 'Article' expect only the properties 'id' and 'name'.
                <code>{ "id": "test", "name": "Phone", "foo": "Bar" }</code> will result in the error:
                <code>WriteError: Article 'test', Unknown property: 'foo' at Article > foo</code>
              </item>
            </list>   
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseSchema.#ctor(Friflo.Json.Fliox.Schema.Definition.TypeSchema)">
            <summary>
            Create a <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/> from the given <paramref name="typeSchema"/>.<br/>
            To create a schema from a class extending <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> prefer using <see cref="M:Friflo.Json.Fliox.Hub.Host.DatabaseSchema.Create``1"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseSchema.#ctor(System.Type)">
            <summary>
            Create as <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/> from the given type. The type must extend <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>.<br/>
            Prefer using <see cref="M:Friflo.Json.Fliox.Hub.Host.DatabaseSchema.Create``1"/> to avoid runtime exception by passing an incompatible schema type. 
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseSchema.Create``1">
            <summary>
            Create as <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/> from the given <typeparamref name="T"/> extending <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.DatabaseSchema.CreateFromType(System.Type)">
            <summary>
            Create as <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseSchema"/> from the given type. The type must extend <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>.<br/>
            Prefer using <see cref="M:Friflo.Json.Fliox.Hub.Host.DatabaseSchema.Create``1"/> to avoid runtime exception by passing an incompatible schema type. 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.ChangeSub.filter">
            <summary>normalized string representation of <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.ChangeSub.jsonFilter"/> used for comparison</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeCombiner">
            <summary>
            Combine container changes - create, upsert, merge and delete - stored in <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.EventCollector"/>
            </summary>
            <remarks>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeCombiner"/> is mainly used for optimization.<br/>
            It combines multiple change tasks - eg. upsert - send from various clients into a single task. <br/>
            This enables sending only a single tasks to subscribed clients instead of sending each change individually. <br/>
            The effects are: <br/>
            - size of serialized events sent to clients is smaller. <br/>
            - serialized events are easier to read by humans. <br/>
            - the CPU / memory cost to serialize events can reduce to O(1) instead O(N) for all clients having
              the same <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubs"/> - See <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeCombiner.rawSyncEvents"/><br/>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeCombiner"/> is not thread safe.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeCombiner.AccumulateChanges(Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubsMap,Friflo.Json.Fliox.Mapper.ObjectWriter)">
            <summary>
            Accumulate all container changes - create, upsert, merge and delete - for the <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.ClientDbSubs"/>
            of each database passed in <paramref name="databaseSubsMap"/>
            </summary>
            <remarks>
            <b>Note</b> Method is not thread safe
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeCombiner.EnqueueSyncEvents(Friflo.Json.Fliox.Hub.Host.Event.ClientDbSubs[],Friflo.Json.Fliox.Mapper.ObjectWriter)">
            <summary>
            Create a serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s for the <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeCombiner.containerChangesSet"/>
            and queue them to the passed <paramref name="clientDbSubs"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeCombiner.CreateSyncEvent(Friflo.Json.Fliox.Hub.Host.Event.Collector.ContainerChanges,Friflo.Json.Fliox.Hub.Host.Event.ChangeSub[],Friflo.Json.Fliox.Mapper.ObjectWriter)">
            <summary>
            Create a serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/> for the passed <paramref name="container"/>
            and <paramref name="changeSubs"/> <br/>
            Return default if no <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/> was created 
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.ContainerChanges">
            <summary>
            Used to collect of changes - create, upsert, merge and delete - of a specific <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.EventCollector">
            <summary>
            Collect entity container changes - create, upsert, merge and delete - for registered <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/>'s <br/>
            Collected changes can be combined by the <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeCombiner"/> at any time.
            </summary>
            <remarks>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.EventCollector"/> is thread safe
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.EventCollector.databaseChangesMap">
            <summary>Thread safe map used to collect the <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.DatabaseChanges"/> for each database</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.Collector.EventCollector.StoreTask(Friflo.Json.Fliox.Hub.Host.EntityDatabase,Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask,Friflo.Json.Fliox.ShortString@)">
            <summary>
            Store a change task in the <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.EventCollector"/> <br/>
            Return true if the given <paramref name="task"/> is stored. Otherwise false.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.Collector.EventCollector.StoreWriteTask(Friflo.Json.Fliox.Hub.Host.Event.Collector.DatabaseChanges,Friflo.Json.Fliox.Hub.Host.EntityContainer,Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType,System.Collections.Generic.List{Friflo.Json.Fliox.JsonEntity},Friflo.Json.Fliox.ShortString@)">
            <summary> Store the entities of a create, upsert or merge tasks </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.Collector.EventCollector.StoreDeleteTask(Friflo.Json.Fliox.Hub.Host.Event.Collector.DatabaseChanges,Friflo.Json.Fliox.Hub.Host.EntityContainer,System.Collections.Generic.ListOne{Friflo.Json.Fliox.JsonKey},Friflo.Json.Fliox.ShortString@)">
            <summary> Store the entity ids of a delete task </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeTask.containerChanges">
            <summary>Used to collect all changes of a specific container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeTask.taskType">
            <summary>The type of container mutation: create, upsert, merge or delete</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeTask.start">
            <summary>start position in either <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.TaskBuffer.values"/> or <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.TaskBuffer.keys"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.ChangeTask.count">
            <summary>item count in either <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.TaskBuffer.values"/> or <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.TaskBuffer.keys"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.TaskBuffer.values">
            <summary>store entities of create, upsert and merge tasks</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.Collector.TaskBuffer.keys">
            <summary>store deleted entities of a delete tasks</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubs">
            <summary>
            Contain all subscriptions to entity changes and messages for a specific database. <br/>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient"/> has a single <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubs"/> instance for each database.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubs.changeSubsMap">
            <summary> key: <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges.container"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubs.changeSubs">
            <summary> 'immutable' array of <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubs.changeSubsMap"/> values use for performance </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubs.CreateEventTasks(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask},Friflo.Json.Fliox.Hub.Host.Event.EventSubClient,System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask}@,Friflo.Json.Fliox.Transform.JsonEvaluator)">
            <summary>
            Create <paramref name="eventTasks"/> for all <paramref name="tasks"/> the <paramref name="subClient"/> subscribed.<br/> 
            Return true if <paramref name="eventTasks"/> were created. Otherwise false.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubs.AddTask(Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask,System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask}@)">
            <summary>Add the <paramref name="task"/> to the <paramref name="eventTasks"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatching">
            <summary>
            Specify the way in which events are send to their targets by an <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher"/><br/>
            Events are generated from the database changes and messages send to a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatching.QueueSend">
            <summary>Events are queued and send asynchronously to their targets</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatching.Queue">
            <summary>
            Events are queued only.<br/>
            The application need to call <see cref="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SendQueuedEvents"/> regularly
            to send events asynchronously to their targets.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatching.Send">
            <summary>
            Events are instantaneously send to their targets when processing a request in <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher">
            <summary>
            An <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher"/> is used to enable Pub-Sub.
            </summary>
            <remarks>
            If assigned to <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.EventDispatcher"/> the <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> send
            push events to clients for database changes and messages these clients have subscribed. <br/>
            In case of remote database connections <b>WebSockets</b> are used to send push events to clients.
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SendTargetClientId">
            <summary>
            If true the target client id is set in <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/>'s sent to clients<br/>
            By sending the client id multiple <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>'s can use a single <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub"/>
            to receive events.<br/>
            If false remote clients like <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketClientHub"/> must be initialized with <see cref="F:Friflo.Json.Fliox.Hub.Remote.RemoteClientAccess.Single"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.syncEventBuffer">
            <summary>buffer for serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s to avoid frequent allocations</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.sendClients">
            <summary> Immutable array of <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient"/>'s stored in <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.sendClientsMap"/><br/>
            Is updated whenever <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.sendClientsMap"/> is modified. Enables enumerating clients without heap allocation.
            This would be the case if sendClientsMap is a ConcurrentDictionary</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SubscribedClientsCount">
            <summary> exposed only for test assertions. <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher"/> lives on Hub. <br/>
            If required its state (subscribed client) can be exposed by <see cref="T:Friflo.Json.Fliox.Hub.DB.Monitor.ClientHits"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.clientEventLoop">
            <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.clientEventLoop"/> and <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.clientEventWriter"/>
            are used as a queue to send pending <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.QueuedEventsCount">
            used for test assertion
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.EnableChangeAccumulation(Friflo.Json.Fliox.Hub.Host.EntityDatabase)">
            <summary>
            Enable container change accumulation.<br/>
            Container changes - create, upsert, merge and delete - send as <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s tasks
            to subscribers are accumulated for the given <paramref name="database"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.DisableChangeAccumulation(Friflo.Json.Fliox.Hub.Host.EntityDatabase)">
            <summary>Disable container change accumulation. See <see cref="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.EnableChangeAccumulation(Friflo.Json.Fliox.Hub.Host.EntityDatabase)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SendRawSyncEvent(Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.Hub.Protocol.RawSyncEvent@,Friflo.Json.Fliox.Mapper.ObjectWriter)">
            <summary>method is thread safe </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SendRawEventMessage(Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.Hub.Protocol.RawEventMessage,Friflo.Json.Fliox.Mapper.ObjectWriter)">
            <summary>method is thread safe </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SendQueuedEvents">
            <summary>
            Send all queued events to all connected subscribers for an <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher"/> initialized with
            <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatching.Queue"/><br/>
            <b>Note</b> Method is not thread-safe. The method can be called from any thread.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.GetSubClientAndDatabaseSubs(Friflo.Json.Fliox.Hub.Host.SyncContext,Friflo.Json.Fliox.Hub.Host.Event.EventSubClient@,Friflo.Json.Fliox.Hub.Host.Event.ClientDbSubs[]@)">
            <summary>use single lock to retrieve <paramref name="subClient"/> and <paramref name="databaseSubsArray"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.FilterSubscribableTasks(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask})">
            <summary>
            Remove all non subscribable tasks from <paramref name="syncTasks"/> <br/>
            Return true if no tasks left to process
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.StoreChangeTasks(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask},Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Store change tasks - create, upsert, merge and delete - if using a <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.Collector.EventCollector"/> <br/>
            Stored change tasks are removed from the given <paramref name="syncTasks"/> list. <br/>
            Return true if no tasks left to process
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.EnqueueSyncTasks(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Create serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s for the passed <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> for
            all <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient"/>'s having matching <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.DatabaseSubs"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SerializeEventTasks(System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask},System.Collections.Generic.List{Friflo.Json.Fliox.JsonValue}@,Friflo.Json.Fliox.Mapper.ObjectWriter,Friflo.Json.Fliox.Utils.MemoryBuffer)">
            <summary>Serialize the passed <paramref name="tasks"/> to <paramref name="tasksJson"/></summary>
            <remarks>
            Optimization:<br/>
            - serialize a task only once for multiple targets<br/>
            - store only a single byte[] for a task instead of a complex SyncRequestTask which is not used anymore<br/>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.RunSendEventLoop(Friflo.Json.Fliox.Hub.Threading.IDataChannelReader{Friflo.Json.Fliox.Hub.Host.Event.EventSubClient})">
            <summary>
            Loop is purely I/O bound => don't wrap in
            return Task.Run(async () => { ... });
            </summary>
            <seealso cref="M:Friflo.Json.Fliox.Hub.Remote.WebSocketHost.RunReceiveMessageLoop"/>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern">
            <summary>
            Contains <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher"/> fields which require a lock(<see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.monitor"/>) when accessing     
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.subClients">
            key: <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.clientId"/>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.sendClientsMap">
            <summary> Subset of <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.subClients"/> eligible for sending events. Either they
            are <see cref="P:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.Connected"/> or they <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.queueEvents"/> </summary> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.databaseSubsMap">
            key: database name
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.SubscribeChanges(Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges,Friflo.Json.Fliox.Hub.Host.Auth.User,Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver)">
            <summary> requires lock <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.monitor"/> </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.GetOrCreateSubClient(Friflo.Json.Fliox.Hub.Host.Auth.User,Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver)">
            <summary> requires lock <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.monitor"/> </summary> 
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.RemoveEmptySubClient(Friflo.Json.Fliox.Hub.Host.Event.EventSubClient)">
            <summary>
            Don't remove empty subClient as the state of <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.eventCounter"/> need to be preserved.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.SubscribeMessage(Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage,Friflo.Json.Fliox.Hub.Host.Auth.User,Friflo.Json.Fliox.ShortString@,Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver)">
            <summary> requires lock <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.monitor"/> </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.UpdateSendClients">
            <summary> requires lock <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.monitor"/> </summary> 
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient">
            <summary>
            Each <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient"/> instance (Event Subscriber Client) - handle the subscriptions for a specific client. <br/>
            It send database changes and messages as events to the client for all subscriptions the client made. <br/>
            A client is identified by its <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.clientId"/>.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.databaseSubs">
            <summary>
            key: database. <b>Note</b> requires lock <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcherIntern.monitor"/>. <br/>
            Use thread safe <see cref="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.GetDatabaseSubs(Friflo.Json.Fliox.Hub.Host.Event.EventSubClient)"/>
            </summary> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.eventCounter">
            lock (<see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.unsentSyncEvents"/>) {
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.unsentSyncEvents">
            <summary>Contains all serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s not yet sent.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.sentEventMessages">
            <summary>Contains all serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/>'s which are sent but not acknowledged.
            TMeta is <see cref="F:Friflo.Json.Fliox.Hub.Protocol.EventMessage.seq"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.resendEventMessages">
            <summary>Set to true if <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.sentEventMessages"/> need to be resend</summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.QueuedEventsCount">
            <summary> number of events stored for a client not yet acknowledged by the client </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.EnqueueSyncEvent(Friflo.Json.Fliox.JsonValue@)">
            <summary>Enqueue serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/> for sending</summary>
            <remarks>
            Note: dispatcher is null in case using <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventDispatching.Queue"/>.<br/>
            So SyncEvent's are collected until calling <see cref="M:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SendQueuedEvents"/>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.DequeueEvents(Friflo.Json.Fliox.Hub.Host.Event.SendEventsContext@)">
            <summary> Dequeue all queued messages. </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.AcknowledgeEventMessages(System.Int32)">
            <summary>
            Remove all acknowledged serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/>' from <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.sentEventMessages"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.SendUnacknowledgedEvents">
            <summary>
            Prepend all not acknowledged events to <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.unsentSyncEvents"/> in their original order
            and trigger sending the events stored in the deque.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.EventSubUser">
            <summary>
            An <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventSubUser"/> - Event Subscriber User - store the <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubUser.groups"/> assigned to a <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubUser.userId"/>. <br/>
            The <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.EventSubUser.groups"/> are used to restrict forwarding message events only to the users part of a specific group.   
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver">
            <summary>
            An <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver"/> is used to send events to clients they have subscribed before.<br/>
            A single <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver"/> can be shared by multiple clients to enable using a single
            remote connection. To address a specific client in case of a shared remote connection the
            <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.ClientEvent.dstClientId"/> is used.
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver.Endpoint">
            <summary>The endpoint events are sent to.<br/>
            E.g. <c>ws:[::1]:52089</c> for WebSockets, <c>udp:127.0.0.1:60005</c> for UDP or <c>in-process</c></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Event.IEventReceiver.SendEvent(Friflo.Json.Fliox.Hub.Host.Event.ClientEvent@)">
            <summary>Send a serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/> to the receiver</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.ClientEvent.dstClientId">
            <summary>the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolEvent.dstClientId"/> of the <see cref="F:Friflo.Json.Fliox.Hub.Host.Event.ClientEvent.message"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.ClientEvent.message">
            <summary>serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.SendEventsContext.syncEvents">
            <summary>Buffer for serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Event.SendEventsContext.eventMessages">
            <summary>Buffer for serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/>'s </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Event.NamespaceDoc">
            <summary>
            Contains the <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher"/> to enable Pub-Sub by a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.HubExtensions.UseClusterDB(Friflo.Json.Fliox.Hub.Host.FlioxHub)">
            <summary>
            Add the <b>cluster</b> database to the given <paramref name="hub"/> providing meta information about hosted databases.
            </summary>
            <remarks>
            This meta information is used by the <b>Hub.Explorer</b> UI to browse hosted databases.<br/>
            The <b>Hub.Explorer</b> UI needs to be added to the <see cref="T:Friflo.Json.Fliox.Hub.Remote.HttpHost"/> with
            <br/>
            <code>
            httpHost.UseStaticFiles(HubExplorer.Path); // nuget: https://www.nuget.org/packages/Friflo.Json.Fliox.Hub.Explorer
            </code>
            <br/>
            <i>Info</i>: to access the <b>cluster</b> database use a <see cref="T:Friflo.Json.Fliox.Hub.DB.Cluster.ClusterStore"/> client.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.HubExtensions.UseMonitorDB(Friflo.Json.Fliox.Hub.Host.FlioxHub)">
            <summary>
            Add the <b>monitor</b> database to the given <paramref name="hub"/> providing access information about
            of the Hub and its databases.
            </summary>
            <remarks>
            Access information:<br/>
            - request and task count executed per user <br/>
            - request and task count executed per client. A user can access without, one or multiple client ids. <br/>
            - events sent to (or buffered for) clients subscribed by these clients. <br/>
            - aggregated access counts of the Hub in the last 30 seconds and 30 minutes.<br/>
            <br/>
            <i>Info</i>: to access the <b>monitor</b> database use a <see cref="T:Friflo.Json.Fliox.Hub.DB.Monitor.MonitorStore"/> client.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.HubExtensions.UsePubSub(Friflo.Json.Fliox.Hub.Host.FlioxHub,Friflo.Json.Fliox.Hub.Host.Event.EventDispatching)">
            <summary>
            Assign an <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.EventDispatcher"/> to the given <paramref name="hub"/> to enable <b>Pub-Sub</b>.
            </summary>
            <remarks>
            It enables sending push events to clients for database changes and messages these clients have subscribed. <br/>
            In case of remote database connections <b>WebSockets</b> are used to send push events to clients.<br/>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.HubExtensions.UseUserDB(Friflo.Json.Fliox.Hub.Host.FlioxHub,Friflo.Json.Fliox.Hub.Host.EntityDatabase,System.String,Friflo.Json.Fliox.Hub.DB.UserAuth.Users)">
            <summary>
            Add the <b>user_db</b> database to the given <paramref name="hub"/> to control individual user access
            to databases their containers and commands.
            </summary>
            <remarks>
            - Each <b>user</b> has a set of <b>roles</b> stored in container <b>permissions</b>. <br/>
            - Each <b>role</b> in container <b>roles</b> has a set of <b>rights</b> which grant or deny container access or command execution.<br/>
            <br/>
            <i>Requirement:</i> the given <paramref name="userDB"/> must be created with
            the <c>schema</c> <see cref="F:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDB.Schema"/> and the <c>service</c> <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserDBService"/> instance. E.g.
            <code>
            new FileDatabase("user_db", "../Test/DB/user_db", UserDB.Schema, new UserDBService())
            </code>
            <br/> 
            <i>Info:</i> to access the <b>user_db</b> database use a <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserStore"/> client.
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.IServiceCommands">
            <summary>
            A class implementing <see cref="T:Friflo.Json.Fliox.Hub.Host.IServiceCommands"/> is used to add custom command handler methods
            annotated with <b><c>[CommandHandler]</c></b> to an <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityDatabase"/>
            using <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.AddCommands(Friflo.Json.Fliox.Hub.Host.IServiceCommands)"/>. E.g. <br/>
            
            <code>
                [CommandHandler]
                async Task&lt;Result&lt;TResult&gt;&gt; MyCommand(Param&lt;TParam&gt; param, MessageContext context)
            </code>
            <br/>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.IServiceCommands"/> are added to a database using <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityDatabase.AddCommands(Friflo.Json.Fliox.Hub.Host.IServiceCommands)"/>
            </summary>
            
            <remarks>
            Additional to commands a class implementing <see cref="T:Friflo.Json.Fliox.Hub.Host.IServiceCommands"/> can also be used to declare message handler methods. E.g.<br/>
            <code>
                [MessageHandler]
                void MyMessage(Param&lt;TParam&gt; param, MessageContext context) { }
            </code>
            <br/>
            <i>Note</i>: Message handler methods - in contrast to command handlers - doesn't return a result.<br/>
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.MessageContext">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.MessageContext"/> expose all data relevant for command execution as properties or methods.
            </summary>
            <remarks>
            In general it provides:
            - the command <see cref="P:Friflo.Json.Fliox.Hub.Host.MessageContext.Name"/> == method name <br/>
            - the <see cref="P:Friflo.Json.Fliox.Hub.Host.MessageContext.Database"/> instance <br/>
            - the <see cref="P:Friflo.Json.Fliox.Hub.Host.MessageContext.Hub"/> exposing general Hub information <br/>
            - a <see cref="T:Friflo.Json.Fliox.Hub.Host.Pool"/> mainly providing common utilities to transform JSON <br/>
            For consistency the API to access the command param is same a <see cref="T:Friflo.Json.Fliox.Hub.Client.IMessage"/>
            </remarks>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Param`1.RawValue">
            <summary>
            Returns the <see cref="T:Friflo.Json.Fliox.Hub.Host.Param`1"/> <see cref="P:Friflo.Json.Fliox.Hub.Host.Param`1.RawValue"/> of a message / command without validation.<br/>
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Param`1.Value">
            <summary>
            Returns the <see cref="T:Friflo.Json.Fliox.Hub.Host.Param`1"/> <see cref="P:Friflo.Json.Fliox.Hub.Host.Param`1.Value"/> of a message / command without validation.<br/>
            Throws an exception in case deserialization fails.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Param`1.Get(`0@,System.String@)">
            <summary>
            Return the command / message <see cref="T:Friflo.Json.Fliox.Hub.Host.Param`1"/> <paramref name="value"/> without validation
            </summary> 
            <param name="value">the param value if conversion successful</param>
            <param name="error">contains the error message if conversion failed</param>
            <returns> true if successful; false otherwise </returns>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Param`1.Get``1(``0@,System.String@)">
            <summary>
            Return the command / message <see cref="T:Friflo.Json.Fliox.Hub.Host.Param`1"/> <paramref name="value"/>
            as the given type <typeparamref name="T"/> without validation
            </summary>
            <param name="value">the param value if conversion successful</param>
            <param name="error">contains the error message if conversion failed</param>
            <returns> true if successful; false otherwise </returns>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Param`1.GetValidate(`0@,System.String@)">
            <summary>
            Return the validated command / message <see cref="T:Friflo.Json.Fliox.Hub.Host.Param`1"/> <paramref name="value"/>
            </summary>
            <param name="value">the param value if conversion successful</param>
            <param name="error">contains the error message if conversion failed</param>
            <returns> true if successful; false otherwise </returns>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Param`1.GetValidate``1(``0@,System.String@)">
            <summary>
            Return the validated command / message <see cref="T:Friflo.Json.Fliox.Hub.Host.Param`1"/> <paramref name="value"/>
            as the given type <typeparamref name="T"/>
            </summary>
            <param name="value">the param value if deserialization is successful</param>
            <param name="error">contains the error message if deserialization fails</param>
            <returns> true if successful; false otherwise </returns>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Result">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.Result"/> contain utility methods to return errors or values of methods annotated with <see cref="T:Friflo.Json.Fliox.CommandHandlerAttribute"/>.<br/>
            E.g the method <see cref="M:Friflo.Json.Fliox.Hub.Host.Result.Error(System.String)"/> to return an error.<br/>
            These methods return their result using a <see cref="T:Friflo.Json.Fliox.Hub.Host.Result`1"/> type.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Result`1">
            <summary>
            Used to return either a result or an error of methods annotated with <see cref="T:Friflo.Json.Fliox.CommandHandlerAttribute"/>.<br/>
            To return errors use one of the error methods of <see cref="T:Friflo.Json.Fliox.Hub.Host.Result"/> like <see cref="M:Friflo.Json.Fliox.Hub.Host.Result.Error(System.String)"/> 
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.SQL.ConnectionPool`1">
            <summary>
            Idle connections are closed and removed from <see cref="T:Friflo.Json.Fliox.Hub.Host.SQL.ConnectionPool`1"/> after <see cref="F:Friflo.Json.Fliox.Hub.Host.SQL.ConnectionPool`1.IdleTimeout"/> ms.  
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.SQL.ConnectionPool`1.connectionPool">
            <summary>
            oldest connection 
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.Json2SQL.DebugKey">
            <summary>Return the primary key of the current row</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQL2Json.GetChars(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.ReadCell@,System.Int32)">
            <summary>
            Fails with Postgres for long strings > ~1000 chars
            DecoderFallbackException: Unable to translate bytes [A4] at index 982 from specified code page to Unicode.
            Postgres requires alternative <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQL2Json.GetString(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.ReadCell@,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQL2Json.GetString(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.ReadCell@,System.Int32)">
            <summary>Required by Postgres. See <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQL2Json.GetChars(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.ReadCell@,System.Int32)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQL2Json.DebugKey">
            <summary>Return the primary key of the current row</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.SQL.ISQL2JsonMapper">
            <summary>
            <b>Important</b> implementations of <see cref="T:Friflo.Json.Fliox.Hub.Host.SQL.ISQL2JsonMapper"/> must not have any state.<br/>
            A singleton is passed to <see cref="T:Friflo.Json.Fliox.Hub.Host.SQL.TableInfo"/> constructor.  
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadEntitiesAsync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.ISQL2JsonMapper,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary> counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadEntitiesSync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.ISQL2JsonMapper,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadObjectsAsync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary> counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadObjectsSync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.QueryEntitiesAsync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary> counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.QueryEntitiesSync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadRowsAsync(System.Data.Common.DbDataReader)">
            <summary> counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadRowsSync(System.Data.Common.DbDataReader)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadEntitiesSync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.ISQL2JsonMapper,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary> counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadEntitiesAsync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.ISQL2JsonMapper,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadObjectsSync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary> counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadObjectsAsync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.QueryEntitiesSync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary> counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.QueryEntitiesAsync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadRowsSync(System.Data.Common.DbDataReader)">
            <summary> counterpart <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLTable.ReadRowsAsync(System.Data.Common.DbDataReader)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLUtils.ReadJsonColumnAsync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities)">
            <summary>
            Prefer using <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLUtils.ReadJsonColumnSync(System.Data.Common.DbDataReader,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities)"/> for SQL Server for performance.<br/>
            reading a single record - asynchronous: ~700 µs, synchronous: 100µs
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLUtils.QueryJsonColumnAsync(System.Data.Common.DbDataReader)">
            <summary>
            Async version of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLUtils.QueryJsonColumnSync(System.Data.Common.DbDataReader)"/><br/>
            Prefer using <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLUtils.QueryJsonColumnSync(System.Data.Common.DbDataReader)"/> for SQL Server for performance.<br/>
            E.g. reading two records - asynchronous: ~700 µs, synchronous: 100µs
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLUtils.QueryJsonColumnSync(System.Data.Common.DbDataReader)">
            <summary>sync version of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SQLUtils.QueryJsonColumnAsync(System.Data.Common.DbDataReader)"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.SQL.ISyncConnection">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Host.SQL.ISyncConnection"/> instances are created on demand per <see cref="T:Friflo.Json.Fliox.Hub.Host.SyncContext"/>.<br/>
            This enables:<br/>
            <list type="bullet">
              <item>Execution of multiple databases commands simultaneously</item>
              <item>Execute a set of database commands (tasks) inside a transaction</item>
            </list> 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.preparedReadOne">
            <summary>
            Each prepared statements is bound to a specific connection<br/>
            See: java - Why are prepared statements kept at a connection level by the JDBC drivers? - Stack Overflow
            https://stackoverflow.com/questions/30034594/why-are-prepared-statements-kept-at-a-connection-level-by-the-jdbc-drivers
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteNonQueryAsync(System.String,System.Data.Common.DbParameter)">
            <summary>async version of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteNonQuerySync(System.String,System.Data.Common.DbParameter)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteAsync(System.String)">
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteSync(System.String)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteReaderAsync(System.String,System.Data.Common.DbParameter)">
            <summary>
            Using asynchronous execution for SQL Server is significant slower.<br/>
            <see cref="M:System.Data.Common.DbCommand.ExecuteReaderAsync"/> ~7x slower than <see cref="M:System.Data.Common.DbCommand.ExecuteReader"/>.
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteReaderSync(System.String,System.Data.Common.DbParameter)"/></summary>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteReaderCommandAsync(System.Data.Common.DbCommand)">
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteReaderCommandSync(System.Data.Common.DbCommand)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.PrepareAsync(System.Data.Common.DbCommand)">
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.Prepare(System.Data.Common.DbCommand)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ReadRelationalReaderAsync(Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ReadRelationalReader(Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteNonQuerySync(System.String,System.Data.Common.DbParameter)">
            <summary>sync version of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteNonQueryAsync(System.String,System.Data.Common.DbParameter)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteSync(System.String)">
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteAsync(System.String)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteReaderSync(System.String,System.Data.Common.DbParameter)">
            <summary>
            Using asynchronous execution for SQL Server is significant slower.<br/>
            <see cref="M:System.Data.Common.DbCommand.ExecuteReaderAsync"/> ~7x slower than <see cref="M:System.Data.Common.DbCommand.ExecuteReader"/>.
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteReaderAsync(System.String,System.Data.Common.DbParameter)"/></summary>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteReaderCommandSync(System.Data.Common.DbCommand)">
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ExecuteReaderCommandAsync(System.Data.Common.DbCommand)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.Prepare(System.Data.Common.DbCommand)">
            <summary>Counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.PrepareAsync(System.Data.Common.DbCommand)"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ReadRelationalReader(Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>counterpart of <see cref="M:Friflo.Json.Fliox.Hub.Host.SQL.SyncDbConnection.ReadRelationalReaderAsync(Friflo.Json.Fliox.Hub.Host.SQL.TableInfo,Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.SQL.ColumnType">
            <summary>
            Same value ids as in <see cref="T:Friflo.Json.Fliox.Schema.Definition.StandardTypeId"/> + enum value <see cref="F:Friflo.Json.Fliox.Hub.Host.SQL.ColumnType.Array"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Utils.HandlerInfo.valueType">
            <summary>
            The type <c>TParam</c> of the <see cref="T:Friflo.Json.Fliox.Hub.Host.Param`1"/> parameter of a method attributed with
            <see cref="T:Friflo.Json.Fliox.CommandHandlerAttribute"/> or <see cref="T:Friflo.Json.Fliox.MessageHandlerAttribute"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Utils.HandlerInfo.resultType">
            <summary>
            For methods attributed with <see cref="T:Friflo.Json.Fliox.CommandHandlerAttribute"/> the type <c>T</c> of a <see cref="T:Friflo.Json.Fliox.Hub.Host.Result`1"/><br/>
            For methods attributed with <see cref="T:Friflo.Json.Fliox.MessageHandlerAttribute"/> the type is <see cref="T:System.Void"/><br/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Utils.EntityProcessor">
            <summary>
            Is used to ensure that <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult"/> returned by <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.ReadEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
            contains valid <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult.entities"/>.
            Validation is required for <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> implementations which cannot ensure that the value of
            its key/values are JSON. See <see cref="M:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult.ValidateEntities(Friflo.Json.Fliox.ShortString@,System.String,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Utils.EntityProcessor.ReadJsonArray(Friflo.Json.Fliox.JsonValue@,System.String@)">
            <summary>
            Parse the given <paramref name="json"/> while expecting the value is a JSON array of objects (entities).
            The JSON objects returned by this method are 1:1 byte identical to its JSON input
            to preserve line feeds and white spaces.
            <br/>
            The common approach using an <see cref="T:Friflo.Json.Fliox.Mapper.ObjectReader"/> with a List of JsonValue's is not used
            as it does not preserve white spaces.   
            <br/>
            Note: The method is independent from <see cref="M:Friflo.Json.Fliox.Hub.Host.Utils.EntityProcessor.Traverse(Friflo.Json.Fliox.JsonValue@,System.String,Friflo.Json.Fliox.JsonKey@,Friflo.Json.Fliox.Hub.Host.Utils.ProcessingType,System.String@)"/> related methods.
            It is placed here as it shares all required parser related properties and
            its purpose is also related to parsing entities.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Host.Utils.KeyValueUtils.CopyEntities(System.Collections.Generic.List{Friflo.Json.Fliox.JsonValue},System.String,System.Nullable{System.Boolean},System.String,System.Collections.Generic.List{Friflo.Json.Fliox.Hub.Protocol.Models.EntityValue},Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Copy the given <paramref name="entities"/> to the given <paramref name="destEntities"/>.
            The given <paramref name="keyName"/> identifies the key property inside the JSON value in the given list of <paramref name="entities"/>.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Host.Utils.QueryEnumerator.detached">
            A non detached enumerator free resources of its internal enumerator when calling <see cref="M:Friflo.Json.Fliox.Hub.Host.Utils.QueryEnumerator.Dispose"/> 
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Host.Utils.QueryEnumerator.UserId">
            Ensure a stored cursor can be accessed only by the user created this cursor
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Host.Utils.SharedTypeStore">
            Singleton are typically a bad practice, but its okay in this case as <see cref="T:Friflo.Json.Fliox.Mapper.TypeStore"/> behaves like an
            immutable object because the mapped types <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> and <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse"/> are
            a fixed set of types. 
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.IHubLogger">
            <summary>
            Implementations of <see cref="T:Friflo.Json.Fliox.Hub.IHubLogger"/> must be thread safe
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.ILogSource">
            <summary> Used unify log interface and identify all classes generating logs </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolMessage">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolMessage"/> is the base type for all messages which are classified into request, response and event.
            </summary>
            <remarks>
            A <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolMessage"/> can also be used in communication going beyond the request / response schema.
            A <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolMessage"/> is either one of the following types:
            <list type="bullet">
              <item> <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest"/>  send by clients / received by hosts</item>
              <item> <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse"/> send by hosts / received by clients</item>
              <item> <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolEvent"/>    send by hosts / received by clients</item>
            </list>
            <i>Note</i>: By applying this classification the protocol can also be used in peer-to-peer networking.
            <para>
                General principle of <see cref="N:Friflo.Json.Fliox"/> message protocol:<br/>
                All messages like requests (their tasks), responses (their results) and events are stateless.<br/>
                In other words: All messages are self-contained and doesn't (and must not) rely and previous sent messages.
                The technical aspect of having a connection e.g. HTTP or WebSocket is not relevant.
                This enables two fundamental features:<br/>
                1. embedding all messages in various communication protocols like HTTP, WebSockets, TCP, WebRTC or datagram based protocols.<br/>
                2. multiplexing of messages from different clients, servers or peers in a shared connection.<br/>
                This also means all <see cref="N:Friflo.Json.Fliox"/> messages doesn't (and must not) require a session.<br/>
                This principle also enables using a single <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> by multiple clients like
                <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> even for remote clients like <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketClientHub"/>.
            </para>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest.reqId">
            <summary>Used only for <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketClientHub"/> to enable:
            <para>
              1. Out of order response handling for their corresponding requests.
            </para>
            <para>
              2. Multiplexing of requests and their responses for multiple clients e.g. <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>
                 using the same connection.
                 This is not a common scenario but it enables using a single <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub"/>
                 used by multiple clients.
            </para>
            The host itself only echos the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest.reqId"/> to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse.reqId"/> and
            does <b>not</b> utilize it internally.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest.clientId">
            <summary>As a user can access a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> by multiple clients the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest.clientId"/>
            enables identifying each client individually. <br/>
            The <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest.clientId"/> is used for <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage"/> and <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges"/>
            to enable sending <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s to the desired subscriber.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse">
            <summary>
            Base type for response messages send from a host to a client in reply of <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>
            </summary>
            <remarks>
            A response is either a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse"/> or a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ErrorResponse"/> in case of a general error.
            </remarks> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse.reqId">
            <summary>Set to the value of the corresponding <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest.reqId"/> of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse.clientId">
            <summary>
            Set to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest.clientId"/> of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> in case the given
            <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest.clientId"/> was valid. Otherwise it is set to null.
            </summary>
            <remarks>
            Calling <see cref="M:Friflo.Json.Fliox.Hub.Host.Auth.Authenticator.EnsureValidClientId(Friflo.Json.Fliox.Hub.Host.Auth.ClientController,Friflo.Json.Fliox.Hub.Host.SyncContext,System.String@)"/> when <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse.clientId"/> == null a
            new unique client id will be assigned. <br/>
            For tasks which require a <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse.clientId"/> a client need to set <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolRequest.clientId"/>
            to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse.clientId"/>. <br/>
            This enables tasks like <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage"/> or <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges"/> identifying the
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/> target. 
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolEvent.dstClientId">
            <summary>
            The target client the event is sent to. This enables sharing a single (WebSocket) connection by multiple clients.
            In many scenarios this property is redundant as every client uses a WebSocket exclusively.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.MessageType">
            <summary>
            The general message types used in the Protocol
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.MessageType.ev">
            <summary>event message - send from host to clients with subscriptions</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.MessageType.sync">
            <summary>request - send from a client to a host</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.MessageType.resp">
            <summary>response - send from a host to a client in reply of a request</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.MessageType.error">
            <summary>response error - send from a host to a client in reply of a request</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.DebugInfoAttribute">
            <summary>
            Annotated fields are only available for debugging ergonomics.
            They are not not used by the library in any way as they represent redundant information.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.ErrorResponse">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ErrorResponse"/> is returned for a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> in case the whole requests failed
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ErrorResponse.message">
            <summary>error message</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ErrorResponse.type">
            <summary>error type: invalid request or execution exception</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ErrorResponseType.BadRequest">
            <summary>Invalid JSON request or invalid request parameters. Maps to HTTP status code 400 (Bad Request)</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ErrorResponseType.Exception">
            <summary>Internal exception. Maps to HTTP status code 500 (Internal Server Error)</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.ErrorResponseType.BadResponse">
            <summary>Invalid JSON response. Maps to HTTP status code 500 (Internal Server Error)</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage">
            <summary>
            Contains a set of <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/>'s. It is send as a push message to clients to deliver the events
            subscribed by these clients.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.EventMessage.seq">
            <summary>
            Increasing event sequence number starting with 1 for a specific target client <see cref="F:Friflo.Json.Fliox.Hub.Protocol.ProtocolEvent.dstClientId"/>.
            Each target client (subscriber) has its own sequence.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.EventMessage.events">
            <summary>
            Each <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/> corresponds to a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> and contains the subscribed
            messages and container changes in its <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasks"/> field
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.RawEventMessage">
            <summary>mimic an <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.RawSyncEvent">
            <summary>mimic a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.RawSyncTask">
            <summary>mimic a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/> corresponds to a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> and contains the subscribed
            messages and container changes in its <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasks"/> field
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.usr">
            <summary>
            The user which caused the event. Specifically the user which made a database change or sent a message / command.<br/>
            By default it is set always. If not required set <see cref="P:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SendEventUserId"/> to false.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.clt">
            <summary>
            The client which caused the event. Specifically the client which made a database change or sent a message / command.<br/>
            By default it set only if the subscriber is the origin of the event to enable ignoring the event.<br/>
            It is set in any case if <see cref="P:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SendEventClientId"/> is true.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.db">
            <summary>
            The database the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasks"/> refer to<br/>
            <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.db"/> is null if the event refers to the default <see cref="F:Friflo.Json.Fliox.Hub.Host.FlioxHub.database"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasks">
            <summary>
            Contains the events an application subscribed. These are:<br/>
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities"/>, 
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities"/>, 
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities"/>,
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendMessage"/>, 
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendCommand"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasksJson">
            Used for optimization. Either <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasks"/> or <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.tasksJson"/> is set
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.EventInfo">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventInfo"/> is never de-/serialized.
            It purpose is to get all aggregated information about a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/> by  by <see cref="M:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.GetEventInfo"/>.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.ChangeInfo">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ChangeInfo"/> is never de-/serialized.
            It purpose is to get aggregated change information about a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncEvent"/> by <see cref="M:Friflo.Json.Fliox.Hub.Protocol.SyncEvent.GetEventInfo"/>.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Models.EntityError">
            <summary>
            Used by <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse"/> to return errors when mutating an entity by: create, upsert, patch and delete
            </summary>
            <remarks> 
            An <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.EntityError"/> needs to be set only, if the access to <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.EntityValue"/>'s
            returned by a previous call to <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.ReadEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> or
            <see cref="M:Friflo.Json.Fliox.Hub.Host.EntityContainer.QueryEntitiesAsync(Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities,Friflo.Json.Fliox.Hub.Host.SyncContext)"/> fails.
            This implies that the previous read or query call was successful.
            </remarks> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityError.id">
            <summary>entity id</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityError.type">
            <summary>error type when accessing an entity in a database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityError.message">
            <summary>error details when accessing an entity</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityError.taskErrorType">
            <summary>Is != <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.None"/> if the error is caused indirectly by a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/> error.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityError.stacktrace">
            <summary>Show the stacktrace if <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityError.taskErrorType"/> == <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.UnhandledException"/>
            and the accessed <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> implementation expose this data.</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Models.EntityErrorType">
            <summary>
            Error type when accessing an entity from a database container  
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityErrorType.ParseError">
            <summary>Invalid JSON when reading an entity from database<br/>
            can happen with key-value databases - e.g. file-system - as their values are not restricted to JSON</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityErrorType.ReadError">
            <summary>Reading an entity from database failed<br/>
            e.g. a corrupt file when using the file-system as database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityErrorType.WriteError">
            <summary>Writing an entity to database failed<br/>
            e.g. the file is already in use by another process when using the file-system as database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityErrorType.DeleteError">
            <summary>Deleting an entity in database failed<br/>
            e.g. the file is already in use by another process when using the file-system as database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityErrorType.PatchError">
            <summary>Patching an entity failed</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Models.Entities">
            <summary>
            Contains an array of tuples: (<see cref="T:Friflo.Json.Fliox.JsonKey"/>, <see cref="T:Friflo.Json.Fliox.JsonValue"/>)<br/>
            </summary>
            <remarks>
            Two aspects of this class<br/>
            - avoid passing array parameters: <c>EntityValue[]</c><br/>
            - be prepared to support array of tuples: (<see cref="T:Friflo.Json.Fliox.JsonKey"/>, <see cref="T:System.Object"/>)
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Models.EntitiesType">
            <summary>The type entities are stored in <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.Entities"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntitiesType.Objects">
            <summary>Entities are stored as an <see cref="T:System.Object"/>[] - an array of reference types</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntitiesType.Values">
            <summary>Entities are stored as an <see cref="T:Friflo.Json.Fliox.JsonValue"/>[]</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Models.References">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.References"/> are used to return entities referenced by fields of entities returned by read and query tasks.<br/>
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.References"/> can be nested to return referenced entities of referenced entities.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.References.selector">
            <remarks>
            Path to a field used as entity reference (secondary key). This field should be annotated with <see cref="T:Friflo.Json.Fliox.RelationAttribute"/>
            The referenced entities are also loaded via the next <see cref="M:Friflo.Json.Fliox.Hub.Client.FlioxClient.SyncTasks"/> request.
            </remarks>
            <summary>the field path used as a reference to an entity in the specified <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.References.container"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.References.container">
            <summary>the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.References.container"/> storing the entities referenced by the specified <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.References.selector"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.ReferencesResult.container">
            <summary>container name - not utilized by Protocol</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.ReferencesResult.len">
            <summary>number of <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.ReferencesResult.set"/> entries - not utilized by Protocol</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.ReferencesResult.foreignKeys">
            <summary>list of foreign keys found for the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.References.selector"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Models.ReferencesResult.entities">
            <summary>entities referenced by the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.ReferencesResult.foreignKeys"/></summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Protocol.Models.ITaskResultError.Error">
            In case a task fails its <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.TaskExecuteError.message"/> is assigned to <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorResult.message"/>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Models.TaskExecuteError">
            <summary>
            Note: A <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Models.TaskExecuteError"/> is never serialized.
            Its fields are assigned to <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorResult"/> which instead is used for serialization of errors.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.NamespaceDoc">
            <summary>
            Specify the <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolMessage"/> types used between a <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> and a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/>  
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> is sent to a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> targeting a specific <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.database"/>.
            </summary>
            <remarks>
            <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> contains a list of <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> used to execute container operations or database commands.
            The <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> returns a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse"/> containing the results for each task.
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.userId">
            <summary>
            Identify the user performing a sync request.
            In case using of using <see cref="T:Friflo.Json.Fliox.Hub.DB.UserAuth.UserAuthenticator"/> the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.userId"/> and <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.token"/>
            are use for user authentication.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.eventAck">
            <summary>
            <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.eventAck"/> is used to ensure (change) events are delivered reliable.
            A client set <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.eventAck"/> to the last received <see cref="F:Friflo.Json.Fliox.Hub.Protocol.EventMessage.seq"/> in case
            it has subscribed to database changes by a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges"/> task.
            Otherwise <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.eventAck"/> is null.
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks">
            <summary>list of tasks either container operations or database commands / messages</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.database">
            <summary>database name the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> apply to. null to access the default database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.info">
            <summary>optional JSON value - can be used to describe a request</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequestIntern">
            <summary>
            Contain fields assigned in <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.InitSyncRequest(Friflo.Json.Fliox.Hub.Protocol.SyncRequest)"/> by using the public fields of the <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse"/> is the response of <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> executed by a <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncResponse.database">
            <summary>for debugging - not used by Protocol</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncResponse.tasks">
            <summary>list of task results corresponding to the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.SyncRequest.tasks"/> in a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.SyncResponse.authError">
            <summary>error message if authentication failed. null for successful authentication</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask">
            <summary>
            Polymorphic base type for all tasks.<br/>
            All tasks fall into two categories:<br/>
            <b>container operations</b> like: create, read, upsert, delete, query, ...<br/>
            <b>database operation</b> like sending commands or messages
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask.IsNop">
            Return true in case a task is a 'No Operation' task. E.g an upsert without entities
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncTaskIntern">
            <summary>
            Contain fields assigned in <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.InitSyncRequest(Friflo.Json.Fliox.Hub.Protocol.SyncRequest)"/> by using the public fields of the <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncTaskIntern.executionType">
            <summary>true if task can be executed synchronous. Otherwise false</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncTaskIntern.json">
            <summary>cached JSON of this <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/> instance serialized as JSON</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType">
            <summary>Type of a task that operates on the database or a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.read">
            <summary>read container entities by id</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.query">
            <summary>query container entities using a filter</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.create">
            <summary>create container entities</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.upsert">
            <summary>upsert container entities</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.merge">
            <summary>patch container entities by id</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.delete">
            <summary>delete container entities by id</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.aggregate">
            <summary>aggregate - count - container entities using a filter</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.message">
            <summary>send a database message</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.command">
            <summary>send a database command</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.closeCursors">
            <summary>close cursors of a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.subscribeChanges">
            <summary>subscribe to entity changes of a container</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.subscribeMessage">
            <summary>subscribe to messages and commands send to a database</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.reserveKeys">
            <summary>wip</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskType.error">
            <summary>indicate an error when task was executed</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorResult">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorResult"/> is returned in case execution of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/> failed
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorResult.type">
            <summary>task error type</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorResult.message">
            <summary>task error details</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorResult.stacktrace">
            <summary>stacktrace in case the error <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorResult.type"/> is a <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.UnhandledException"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType">
            <summary>Type of a task error used in <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorResult"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.None">
            HTTP status: 500
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.UnhandledException">
            <summary>
            Unhandled exception while executing a task.<br/>
            maps to HTTP status: 500
            </summary>
            <remarks>
            Unhandled exceptions in a <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> implementations need to be fixed.<br/>
            More information at <see cref="M:Friflo.Json.Fliox.Hub.Host.FlioxHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>.
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.DatabaseError">
            <summary>General database error while task execution.<br/>
            E.g. the access is currently not available or accessing a missing table.<br/>
            maps to HTTP status: 500 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.FilterError">
            <summary>Invalid query filter   <br/> maps to HTTP status: 400</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.ValidationError">
            <summary>Schema validation of an entity failed  <br/> maps to HTTP status: 400</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.CommandError">
            <summary>Execution of message / command failed caused by invalid input  <br/>maps to HTTP status: 400</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.InvalidTask">
            <summary>Invalid task. E.g. by using an invalid task parameter  <br/>maps to HTTP status: 400</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.NotImplemented">
            <summary>database message / command not implemented     <br/>maps to HTTP status: 501</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.PermissionDenied">
            <summary>task execution not authorized  <br/>maps to HTTP status: 403</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.SyncError">
            <summary>The entire <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> containing a task failed  <br/>maps to HTTP status: 500</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.EntityErrors">
            <summary>
            Is set if a read or query result contains specific entity errors.
            See: <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult.errors"/> / <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntitiesResult.errors"/><br/>
            The entity errors are available via <see cref="F:Friflo.Json.Fliox.Hub.Client.TaskError.entityErrors"/>.  
            </summary>
            <remarks>client specific error</remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.TaskErrorType.InvalidResponse">
            <summary>Use to indicate an invalid response.</summary>
            <remarks>client specific error</remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities">
            <summary>
            Aggregate - count - entities from the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities.container"/> using a <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities.filter"/><br/> 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities.container">
            <summary>container name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities.type">
            <summary>aggregation type - e.g. count </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities.filterTree">
            <summary>aggregation filter as JSON tree. <br/>
            Is used in favour of <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities.filter"/> as its serialization is more performant</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities.filter">
            <summary>aggregation filter as a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions">Lambda expression</a>
            returning a boolean value. E.g.<br/>
            <code>o => o.name == 'Smartphone'</code>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntitiesResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities"/> task
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntitiesResult.container">
            <summary>container name - not utilized by Protocol</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateType">
            <summary>
            Aggregation type used in <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateEntities"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.AggregateType.count">
            <summary>count entities</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.CloseCursors">
            <summary>
            Close the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CloseCursors.cursors"/> of the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CloseCursors.container"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CloseCursors.container">
            <summary>container name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CloseCursors.cursors">
            <summary>list of <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CloseCursors.cursors"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Protocol.Tasks.CloseCursors.RemoveCursors(Friflo.Json.Fliox.Hub.Host.EntityContainer,System.Collections.Generic.List{System.String},Friflo.Json.Fliox.Hub.Host.Auth.User)">
            <summary> Note: A <paramref name="user"/> can remove only its own cursors </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.CloseCursorsResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.CloseCursors"/> task
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities">
            <summary>
            Create the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities.entities"/> in the specified <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities.container"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities.container">
            <summary>container name the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities.entities"/> are created</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities.keyName">
            <summary>name of the primary key property in <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities.entities"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities.entities">
            <summary>the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities.entities"/> which are created in the specified <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities.container"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntitiesResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntities"/> task
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.CreateEntitiesResult.errors">
            <summary>list of entity errors failed to create</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities">
            <summary>
            Delete entities by id in the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities.container"/><br/>
            The entities which will be deleted are listed in <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities.ids"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities.container">
            <summary>container name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities.ids">
            <summary>list of <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities.ids"/> requested for deletion</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities.all">
            <summary>if true all entities in the specified <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities.container"/> are deleted</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntitiesResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntities"/> task
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.DeleteEntitiesResult.errors">
            <summary>list of entity errors failed to delete</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities">
            <summary>
            Merge entities by id in the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities.container"/><br/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities.container">
            <summary>container name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities.keyName">
            <summary>name of the primary key property of the entity <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities.patches"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities.patches">
            <summary>list of merge patches for each entity</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntitiesResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntities"/> task
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.MergeEntitiesResult.errors">
            <summary>list of entity errors failed to patch</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.NamespaceDoc">
            <summary>
            Specify the <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncRequestTask"/> models contained within <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> tasks
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities">
            <summary>
            Query entities from the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.container"/> using a <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.filter"/><br/>
            To return entities referenced by fields of the query result use <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.references"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.container">
            <summary>container name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.keyName">
            <summary>name of the primary key property of the returned entities</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.filterTree">
            <summary>
            query filter as JSON tree. <br/>
            Is used in favour of <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.filter"/> as its serialization is more performant
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.filter">
            <summary>
            query filter as a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions">Lambda expression</a>
            returning a boolean value. E.g.<br/>
            <code>o => o.name == 'Smartphone'</code>
            if <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.filterTree"/> is assigned it has priority
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.references">
            <summary>used to request the entities referenced by properties of the query task result</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.limit">
            <summary>limit the result set to the given number</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.maxCount">
            <summary>If set the query uses or creates a <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.cursor"/> and return <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.maxCount"/> number of entities.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.cursor">
            <summary>specify the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.cursor"/> of a previous cursor request</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntitiesResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities"/> task
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntitiesResult.container">
            <summary>container name - not utilized by Protocol</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntitiesResult.len">
            <summary>number of <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntitiesResult.set"/> values - not utilized by Protocol</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntitiesResult.set">
            <summary>the result set of entities matching the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.filter"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntitiesResult.references">
            <summary>the referenced entities specified in <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.QueryEntities.references"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities">
            <summary>
            Read entities by id from the specified <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.container"/> using given list of <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.ids"/><br/>
            To return also entities referenced by entities listed in <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.ids"/> use <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.references"/>. <br/>
            This mimic the functionality of a <b>LEFT JOIN</b> in <b>SQL</b>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.container">
            <summary>container name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.keyName">
            <summary> name of the primary key property of the returned entities </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.ids">
            <summary> list of requested entity <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.ids"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.references">
            <summary> used to request the entities referenced by properties of a read task result </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities"/> task
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult.set">
            <summary>the result set of entities requested by <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.ids"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult.references">
            <summary>the referenced entities specified in <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntities.references"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult.ValidateEntities(Friflo.Json.Fliox.ShortString@,System.String,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            Validate all <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Models.EntityValue.value"/>'s in the result set.
            Validation is required for all <see cref="T:Friflo.Json.Fliox.Hub.Host.EntityContainer"/> implementations which cannot ensure that the
            <see cref="P:Friflo.Json.Fliox.Hub.Protocol.Models.EntityValue.Json"/> value of <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult.entities"/> is valid JSON.
            
            E.g. <see cref="T:Friflo.Json.Fliox.Hub.Host.FileContainer"/> cannot ensure this, as the file content can be written
            or modified from external processes - for example by manually changing its JSON content with an editor.
            
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.MemoryContainer"/> does not require validation as its key/values are always written via
            Fliox.Hub.Client library - which generate valid JSON.
            
            So database adapters which can ensure the JSON value is always valid made calling <see cref="M:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReadEntitiesResult.ValidateEntities(Friflo.Json.Fliox.ShortString@,System.String,Friflo.Json.Fliox.Hub.Host.SyncContext)"/>
            obsolete - like Postgres/JSONB, Azure Cosmos DB or MongoDB.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReserveKeys">
            <summary>
            WIP
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReserveKeysResult">
            <summary>
            WIP
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.ReservedKeys">
            <summary>
            WIP
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendCommand">
            <summary>
            Send a database command with the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.param"/>. <br/>
            In case <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.users"/> or <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.clients"/> is set the Hub forward
            the message as an event only to the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.users"/> or <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.clients"/>.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendCommandResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendCommand"/> task
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask">
            <summary>
            Used as base type for <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendMessage"/> or <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendCommand"/> to specify the command / message
            <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.name"/> and <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.param"/>. <br/>
            In case <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.users"/> or <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.clients"/> is set the Hub forward the message as an event only to the
            given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.users"/> or <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.clients"/>. 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.name">
            <summary>command / message name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.param">
            <summary>command / message parameter. Can be null or absent</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.users">
            <summary>if set the Hub forward the message as an event only to given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.users"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.clients">
            <summary>if set the Hub forward the message as an event only to given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.clients"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.groups">
            <summary>if set the Hub forward the message as an event only to given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.groups"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.PreExecute(Friflo.Json.Fliox.Hub.Protocol.Tasks.PreExecute@)">
            <summary>
            return true to execute this task synchronous. <br/>
            return false to execute task asynchronous
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendMessage">
            <summary>
            Send a database message with the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.param"/>. <br/>
            In case <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.users"/> or <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.clients"/> is set the Hub forward
            the message as an event only to the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.users"/> or <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SyncMessageTask.clients"/>. 
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendMessageResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SendMessage"/> task
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges">
            <summary>
            Subscribe to specific <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges.changes"/> of the specified <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges.container"/> using the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges.filter"/> 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges.container">
            <summary>container name</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges.changes">
            <summary>subscribe to entity <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges.changes"/> of the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges.container"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges.filter">
            <summary>subscription filter as a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions">Lambda expression</a> (infix notation)
            returning a boolean value. E.g. <c>o => o.name == 'Smartphone'</c></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChangesResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeChanges"/> task
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.EntityChange">
            <summary>Filter type used to specify the type of an entity change</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.EntityChange.create">
            <summary>filter change events of created entities.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.EntityChange.upsert">
            <summary>filter change events of upserted entities.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.EntityChange.merge">
            <summary>filter change events of entity patches.</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.EntityChange.delete">
            <summary>filter change events of deleted entities.</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage">
            <summary>
            Subscribe to commands and messages sent to a database by their <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage.name"/><br/>
            Unsubscribe by setting <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage.remove"/> to true 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage.name">
            <summary>subscribe a specific message: 'std.Echo', multiple messages by prefix: 'std.*', all messages: '*'</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage.remove">
            <summary>if true a previous added subscription is removed. Otherwise added</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessageResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.SubscribeMessage"/> task
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities">
            <summary>
            Upsert the given <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities.entities"/> in the specified <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities.container"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities.container">
            <summary>container name the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities.entities"/> are upserted - created or updated</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities.keyName">
            <summary>name of the primary key property in <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities.entities"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities.entities">
            <summary>the <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities.entities"/> which are upserted in the specified <see cref="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities.container"/></summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntitiesResult">
            <summary>
            Result of a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntities"/> task
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Protocol.Tasks.UpsertEntitiesResult.errors">
            <summary>list of entity errors failed to upsert</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.IRemoteServer.Run">
            <summary>
            Implementations should use<br/>
            <c>.GetAwaiter().GetResult();</c><br/>
            instead of<br/>
            <c>.Wait()</c><br/>
            to get a more useful stacktrace in case of exceptions. See<br/>
            https://stackoverflow.com/questions/36426937/what-is-the-difference-between-wait-vs-getawaiter-getresult
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.RemoteHostEnv.fakeOpenClosedSockets">
            Only set to true for testing. It avoids an early out at <see cref="M:Friflo.Json.Fliox.Hub.Host.Event.EventSubClient.SendEvents(Friflo.Json.Fliox.Hub.Host.Event.SendEventsContext@)"/>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.SocketMetrics">
            <summary>
            Time values are the difference of two timestamps: endTime - startTime <br/>
            timestamps are used from <see cref="M:System.Diagnostics.Stopwatch.GetTimestamp"/>
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.SocketMetrics.receivedCount">
            <summary> accumulated count of all received WebSocket messages </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.SocketMetrics.requestReadTime">
            <summary> accumulated read request time of all WebSocket's </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.SocketMetrics.requestExecuteTime">
            <summary> accumulated request execution time of all WebSocket's </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.StaticFileHandler">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Remote.StaticFileHandler"/> is used to serve static files by a <see cref="T:Friflo.Json.Fliox.Hub.Remote.HttpHost"/>.
            </summary>
            <remarks>
            Therefore add an instance of <see cref="T:Friflo.Json.Fliox.Hub.Remote.StaticFileHandler"/> with <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpHost.AddHandler(Friflo.Json.Fliox.Hub.Remote.IRequestHandler)"/> to the Hub.<br/>
            The <b>Media Type</b> assigned to the response <c>Content-Type</c> header is derived from the file name extension.<br/>
            Add additional mappings for <b>file name extension</b> to <b>MediaType</b> with <see cref="M:Friflo.Json.Fliox.Hub.Remote.StaticFileHandler.AddFileExtension(System.String,System.String)"/>.
            </remarks> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Rest.RestRequest.query">
            query string of the url. E.g. ?cmd=std.Echo
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Rest.RestRequest.#ctor(Friflo.Json.Fliox.Hub.Remote.Rest.RestRequestType,System.String,System.String,Friflo.Json.Fliox.JsonValue@)">
            <summary>
            create request specific for <see cref="F:Friflo.Json.Fliox.Hub.Remote.Rest.RestRequestType.message"/> and <see cref="F:Friflo.Json.Fliox.Hub.Remote.Rest.RestRequestType.command"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Rest.RestRequest.#ctor(Friflo.Json.Fliox.Hub.Remote.Rest.RestRequestType,System.String,System.String,Friflo.Json.Fliox.JsonKey[])">
            <summary>
            create request for a database container operation
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Rest.RestRequest.#ctor(Friflo.Json.Fliox.Hub.Remote.Rest.RestRequestType,System.String,System.String,System.String,Friflo.Json.Fliox.JsonValue@,System.Collections.Specialized.NameValueCollection)">
            <summary>
            create request for a database container operation
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Rest.RestRequest.#ctor(System.String,System.String,System.Int32)">
            <summary>
            create request for <see cref="F:Friflo.Json.Fliox.Hub.Remote.Rest.RestRequestType.error"/>'s
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.Rest.RestUtils">
            <summary>static class to ensure all REST methods are static</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Rest.RestUtils.InvalidFilter">
            enforce "o" as lambda argument
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Schema.SchemaResource.modelResources">
            key: <see cref="F:Friflo.Json.Fliox.Schema.Language.SchemaModel.type"/>  (csharp, typescript, ...)
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.Test.HttpFile">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Remote.Test.HttpFile"/> is used to run multiple HTTP requests given in a simple text file used for concise regression tests
            </summary>
            <remarks>
            The text file format is compatible to:
            <a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">REST Client - Visual Studio Marketplace</a>
            <br/>
            This approach enables request execution in multiple ways:
            <list type="bullet">
              <item> automated by unit tests </item>
              <item> individually by using an IDE - e.g. the mentioned REST Client or Rider </item>
            </list>
            Other benefits using this approach:
            <list type="bullet">
              <item>
                avoid flooding the test suite with primitive tests
              </item>
              <item>
                simplify adjusting test results in case of behavior changes (e.g. bugfix or enhancements) by simplify
                committing the modified request response to version control.
              </item>
              <item>
                avoid writing test assertions using difficult string literals caused by escaped characters or line feeds
              </item>
            </list>
            This class is utilized by <b>Friflo.Json.Tests.Common.UnitTest.Fliox.Remote.TestRemote</b>
            to write a single output file for a given request file.
            <br/>
            The generated output files are intended to be added to version control.
            The expectation is that after running the tests the output files are <b>unmodified</b> in version control (Git). <br/>
            In case an output file is <b>modified</b> its new version have to be added to version control if the modifications meets expectation.
            </remarks> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Tools.JsonResponseStatus.Ok">
            maps to HTTP 200 OK
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Tools.JsonResponseStatus.Error">
            maps to HTTP 400 Bad Request
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Tools.JsonResponseStatus.Exception">
            maps to HTTP 500 Internal Server Error
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Tools.JsonResponse.body">
            <summary><b>Attention</b> <see cref="F:Friflo.Json.Fliox.Hub.Remote.Tools.JsonResponse.body"/> is <b>only</b> valid until used <see cref="T:Friflo.Json.Fliox.Mapper.ObjectMapper"/> is reused </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Tools.JsonResponse.CreateError(Friflo.Json.Fliox.Mapper.ObjectWriter,System.String,Friflo.Json.Fliox.Hub.Protocol.ErrorResponseType,System.Nullable{System.Int32})">
            <summary>
            <b>Attention</b> returned <see cref="T:Friflo.Json.Fliox.Hub.Remote.Tools.JsonResponse"/> is <b>only</b> valid until the passed <paramref name="writer"/> is reused
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Tools.RemoteRequest.response">
            <summary>
            After a client send a remote request to the host the <see cref="F:Friflo.Json.Fliox.Hub.Remote.Tools.RemoteRequest.response"/> is used to await its completion
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.HttpClientHub">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> accessed remotely using a <see cref="T:System.Net.Http.HttpClient"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.HttpHost">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Remote.HttpHost"/> enables remote access to databases, schemas and static web files via
            <b>HTTP</b> or <b>WebSockets</b>.
            </summary>
            <remarks>
            The full feature set is listed at:
            <a href="https://github.com/friflo/Friflo.Json.Fliox/blob/main/Json/Fliox.Hub/Host/README.md#httphost">Host README.md</a><br/>
            In detail:
            <list type="bullet">
              <item>hosted databases are given by the <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> passed via its constructor
                <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpHost.#ctor(Friflo.Json.Fliox.Hub.Host.FlioxHub,System.String,Friflo.Json.Fliox.Hub.Host.SharedEnv)"/>
              </item>
              <item>exposed schemas are retrieved from the hosted databases</item>
              <item>static web files are exposed by adding a <see cref="T:Friflo.Json.Fliox.Hub.Remote.StaticFileHandler"/> using <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpHost.AddHandler(Friflo.Json.Fliox.Hub.Remote.IRequestHandler)"/></item>
            </list>
            
            A <see cref="T:Friflo.Json.Fliox.Hub.Remote.HttpHost"/> can be integrated by any HTTP server like like <b>ASP.NET Core / Kestrel</b>
            or the <see cref="T:System.Net.HttpListener"/> part of the .NET Base Class library (BCL). <br/>
            <br/>
            A <see cref="T:Friflo.Json.Fliox.Hub.Remote.HttpHost"/> can be accessed remotely by: <br/>
            <list type="bullet">
              <item>Send <b>Batch</b> requests using a <b>POST</b> to <b><c>./fliox</c></b> - containing multiple tasks </item>
              <item>Send <b>Batch</b> requests containing multiple tasks via a <b>WebSocket</b> at <b><c>./fliox</c></b></item>
              <item><b>REST</b> API to POST, GET, PUT, DELETE and PATCH with via a path like <b><c>./fliox/rest/database/container/id</c></b> </item>
              <item><b>GraphQL</b> via an endpoint like <b><c>/fliox/graphql/database</c></b> - requires package: Friflo.Json.Fliox.Hub.GraphQL</item>
            </list>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.HttpHost.baseRoute">
            <summary>never null, ends with '/'</summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.HttpHost.ExecuteHttpRequest(Friflo.Json.Fliox.Hub.Remote.RequestContext)">
            <summary>
            Central point where all Fliox related HTTP requests arrive.
            Each request is dispatched by a matching request handler. 
            <br/>
            Note:
            Request matching and execution are separated to ensure no heap allocation caused by awaited method calls. 
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.HttpHostExtensions.UseStaticFiles(Friflo.Json.Fliox.Hub.Remote.HttpHost,System.String)">
            <summary>
            Serve static files in the given <paramref name="folder"/> via HTTP by the given <paramref name="httpHost"/>.
            </summary>
            <remarks>
            Its main purpose is to add the static web files of the <b>Hub Explorer</b>.<br/>
            As the Hub Explorer is optional and only required by server applications they are published in
            a separate nuget package https://www.nuget.org/packages/Friflo.Json.Fliox.Hub.Explorer/<br/>
            To add its files use:
            <br/>
            <code>
            httpHost.UseStaticFiles(HubExplorer.Path); // nuget: https://www.nuget.org/packages/Friflo.Json.Fliox.Hub.Explorer
            </code>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.HttpHostUtils.GetFlioxRoute(Friflo.Json.Fliox.Hub.Remote.HttpHost,System.String,System.String@)">
            <summary>
            Returns true if the given <paramref name="path"/> is handled by the <see cref="T:Friflo.Json.Fliox.Hub.Remote.HttpHost"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.HttpHostUtils.ExecuteUnknownPath(Friflo.Json.Fliox.Hub.Remote.HttpHost,System.String,System.String)">
            <summary>
            Perform a redirect from /fliox -> /fliox/ <br/>
            Otherwise return a path mapping error. <br/>
            E.g. in case ASP.NET maps <c>"/foo/{*path}"</c> to a an <see cref="F:Friflo.Json.Fliox.Hub.Remote.HttpHost.baseRoute"/> <c>"/fliox/"</c> 
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.HttpServer">
            <summary>
            <see cref="T:Friflo.Json.Fliox.Hub.Remote.HttpServer"/> is a utility class to enable running a simple HTTP Server by using a <see cref="T:System.Net.HttpListener"/>
            </summary>
            <remarks>
            Via its utility methods is manages the lifecycle of a <see cref="T:System.Net.HttpListener"/>.
            Lifecycle methods:
            <list type="bullet">
                <item>Create an instance: <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpServer.#ctor(System.String,Friflo.Json.Fliox.Hub.Remote.HttpHost)"/></item>
                <item>Start server: <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpServer.Start"/></item>
                <item>Run server loop for incoming connections: <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpServer.Run"/></item>
                <item>Stop server: <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpServer.Stop"/></item>
                <item>Shutdown server: <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpServer.Dispose"/></item>
            </list>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.HttpServer.RunHost(System.String,Friflo.Json.Fliox.Hub.Remote.HttpHost)">
            <summary>
            Start and run a simple HTTP server using the given <paramref name="httpHost"/>
            on the <paramref name="endpoint"/> using the <see cref="T:System.Net.HttpListener"/> of the BCL.  
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.HttpServerExtensions.ExecuteFlioxRequest(System.Net.HttpListenerContext,Friflo.Json.Fliox.Hub.Remote.HttpHost)">
            <summary>
            Execute the request return a RequestContext containing the execution result.
            To return a HTTP response <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpServerExtensions.WriteFlioxResponse(System.Net.HttpListenerContext,Friflo.Json.Fliox.Hub.Remote.RequestContext)"/> need to be called. 
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.HttpServerExtensions.WriteFlioxResponse(System.Net.HttpListenerContext,Friflo.Json.Fliox.Hub.Remote.RequestContext)">
            <summary>
            Write the result of <see cref="M:Friflo.Json.Fliox.Hub.Remote.HttpServerExtensions.ExecuteFlioxRequest(System.Net.HttpListenerContext,Friflo.Json.Fliox.Hub.Remote.HttpHost)"/> to the given <paramref name="context"/>
            </summary>
        </member>
        <member name="P:Friflo.Json.Fliox.Hub.Remote.IRequestHandler.Routes">
            <summary>
            The handled routes of an <see cref="T:Friflo.Json.Fliox.Hub.Remote.IRequestHandler"/> implementation  
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.IRequestHandler.IsMatch(Friflo.Json.Fliox.Hub.Remote.RequestContext)">
            <summary>
            Return true if request can be handled by <see cref="T:Friflo.Json.Fliox.Hub.Remote.IRequestHandler"/> implementation
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.IRequestHandler.HandleRequest(Friflo.Json.Fliox.Hub.Remote.RequestContext)">
            <summary>
            return true if request was handled.
            Otherwise false to enable subsequent handlers processing the request  
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.RequestContext">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Remote.RequestContext"/> is used to get the data of a HTTP request from a specific HTTP server
            and provide its execution results back to the HTTP server.    
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.RemoteClientAccess">
            <summary>
            By default a remote client like <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketClientHub"/> can be used by multiple <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>'s.<br/>
            <br/>
            To minimize the size of serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.EventMessage"/>'s sent to subscribed clients the <see cref="T:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher"/>
            can omit sending the target client id by settings <see cref="P:Friflo.Json.Fliox.Hub.Host.Event.EventDispatcher.SendTargetClientId"/> to false.<br/>
            In this case all <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketClientHub"/>'s must be initialized with <see cref="F:Friflo.Json.Fliox.Hub.Remote.RemoteClientAccess.Single"/> enabling
            processing events by the single <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> using a <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketClientHub"/>. 
            </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.RemoteClientAccess.Single">
            <summary>Remote client can be used only by a single <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/></summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.RemoteClientAccess.Multi">
            <summary>Remote client can be used by multiple <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/>'s</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.SocketClientHub">
            <summary>
            Counterpart of <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketHost"/> used by socket implementations running on clients.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.SocketClientHub.ExecuteRequestAsync(Friflo.Json.Fliox.Hub.Protocol.SyncRequest,Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            A class extending  <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketClientHub"/> must implement this method.<br/>
            Implementation must be thread-safe as multiple <see cref="T:Friflo.Json.Fliox.Hub.Client.FlioxClient"/> instances are allowed to
            use a single <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> instance simultaneously.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.SocketClientHub.OnReceive(Friflo.Json.Fliox.JsonValue@,Friflo.Json.Fliox.Hub.Remote.Tools.RemoteRequestMap,Friflo.Json.Fliox.Mapper.ObjectReader)">
            <summary>
            Method is not thread safe.<br/>
            Expectation is calling this method sequentially from a receive message loop.  
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.SocketHost">
            <summary>
            Counterpart of <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketClientHub"/> used by socket implementations running on the server.<br/>
            <br/>
            <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketHost"/> provide a set of methods to:<br/>
            - parse serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/> messages.<br/>
            - execute <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>'s and send serialized <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncResponse"/> to client<br/>
            <br/>
            <see cref="T:Friflo.Json.Fliox.Hub.Remote.SocketHost"/> is thread safe.
            </summary>
            <remarks>
            The implementation aims to prevent <b>head-of-line blocking</b>.<br/>
            Which means it supports <b>out-of-order delivery</b> for responses send to clients.<br/>
            <br/>
            <b>Special case</b><br/>
            If enabling queueing request in <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseService"/>
            <b>head-of-line blocking</b> can occur in case request execution is not 'instant'<br/>
            <br/>
            Requests can be executed synchronous, asynchronous or on a specific thread / execution context.<br/>
            - If <see cref="T:Friflo.Json.Fliox.Hub.Host.DatabaseService"/> is configured to queue requests they are executed
              on the thread calling <see cref="F:Friflo.Json.Fliox.Hub.Host.DatabaseService.queue"/> <br/>
            - Synchronous in case a request can be executed synchronous<br/>
            - Asynchronous in case a request requires asynchronous execution<br/>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.SocketHost.CreateSyncContext">
            <summary>create or use a pooled <see cref="T:Friflo.Json.Fliox.Hub.Host.SyncContext"/></summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.SocketHost.ReturnSyncContext(Friflo.Json.Fliox.Hub.Host.SyncContext)">
            <summary>
            <b>Note</b> <br/>
            Return <see cref="T:Friflo.Json.Fliox.Hub.Host.SyncContext"/> to syncContextPool after calling <see cref="M:Friflo.Json.Fliox.Hub.Remote.SocketHost.SendResponse(Friflo.Json.Fliox.Hub.Host.ExecuteSyncResult@,System.Nullable{System.Int32})"/> or <see cref="M:Friflo.Json.Fliox.Hub.Remote.SocketHost.SendResponseException(System.Exception,System.Nullable{System.Int32})"/>
            as <see cref="P:Friflo.Json.Fliox.Hub.Host.SyncContext.MemoryBuffer"/> could be used when writing <see cref="T:Friflo.Json.Fliox.Hub.Remote.Tools.JsonResponse"/>.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServer.RunSendMessageLoop">
            <summary>
            Loop is purely I/O bound => don't wrap in
            return Task.Run(async () => { ... });
            </summary>
            <remarks>
            A send loop reading from a queue is required as message can be sent from two different sources <br/>
            1. response messages created in <see cref="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServer.ReceiveMessageLoop"/> <br/>
            2. event messages send with <see cref="M:Friflo.Json.Fliox.Hub.Remote.SocketHost.SendEvent(Friflo.Json.Fliox.Hub.Host.Event.ClientEvent@)"/>'s <br/>
            The loop ensures a UdpClient.SendAsync() is called only once at a time.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServer.SendMessageLoop">
            Send queue is required to ensure having only a single outstanding SendAsync() at any time
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServer.ReceiveMessageLoop">
            <summary>
            Parse, execute and send response message for all received request messages.<br/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServer.SendReceiveMessages">
            <summary>
            Create a send and receive queue and run a send and a receive loop. <br/>
            The loops are executed until the WebSocket is closed or disconnected. <br/>
            The method <b>don't</b> throw exception. WebSocket exceptions are catched and written to <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.Logger"/> <br/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocket">
            <summary>
            Store send requests in the <see cref="F:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocket.requestMap"/> to map received response messages to its related <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocket.#ctor(System.Int32)">
            <summary>if port == 0 an available port is used</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketClientHub">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> accessed remotely  using a <see cref="T:System.Net.Sockets.UdpClient"/> connection<br/>
            </summary>
            <remarks>
            Counterpart of <see cref="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketHost"/> used by clients.<br/>
            Implementation aligned with <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub"/>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketClientHub.reqId">
            Incrementing requests id used to map a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse"/>'s to its related <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>.
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketClientHub.#ctor(System.String,System.String,System.Int32,Friflo.Json.Fliox.Hub.Host.SharedEnv,Friflo.Json.Fliox.Hub.Remote.RemoteClientAccess)">
            <summary>
            if port == 0 an available port is used
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketClientHub.ReceiveMessageLoop">
            <summary>
            Has no SendMessageLoop() - client send only response messages via <see cref="M:Friflo.Json.Fliox.Hub.Remote.SocketClientHub.OnReceive(Friflo.Json.Fliox.JsonValue@,Friflo.Json.Fliox.Hub.Remote.Tools.RemoteRequestMap,Friflo.Json.Fliox.Mapper.ObjectReader)"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketHost">
            <summary>
            Implementation aligned with <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSocketHost"/>
            </summary>
            <remarks>
            Counterpart of <see cref="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketClientHub"/> used by the server.<br/>
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.IPEndPointCache">
            <summary>
            Optimization specific for Unity to avoid heap allocation in Socket.ReceiveFrom() method caused by
            <see cref="M:System.Net.IPEndPoint.Serialize"/>.<br/>
            Class is not used in CLR.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.IPEndPointCache.Serialize">
            Method is called from Socket.ReceiveFrom() in Unity 2021.3.9f1. Not utilized in CLR. 
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.IPEndPointCache.Create(System.Net.SocketAddress)">
            Method is called from Socket.ReceiveFrom() in Unity 2021.3.9f1. It is not called in MS CLR
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.IPEndPointReuse">
            <summary>
            Optimization specific for Unity to avoid heap allocation in Socket.SendTo() methods caused by
            <see cref="M:System.Net.IPEndPoint.Serialize"/>.<br/>
            Class is not used in CLR.
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.IPEndPointReuse.Create(System.Net.SocketAddress)">
            Method is called from Socket.SendTo() in Unity 2021.3.9f1. Not utilized in CLR. 
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServerSync.RunSendMessageLoop">
            <summary>
            Loop is purely I/O bound => don't wrap in
            return Task.Run(async () => { ... });
            </summary>
            <remarks>
            A send loop reading from a queue is required as message can be sent from two different sources <br/>
            1. response messages created in <see cref="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServerSync.Receiver.ReceiveMessageLoop"/> <br/>
            2. event messages send with <see cref="M:Friflo.Json.Fliox.Hub.Remote.SocketHost.SendEvent(Friflo.Json.Fliox.Hub.Host.Event.ClientEvent@)"/>'s <br/>
            The loop ensures a UdpClient.SendAsync() is called only once at a time.
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServerSync.SendMessageLoop">
            Send queue is required to ensure having only a single outstanding SendAsync() at any time
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServerSync.Receiver.ReceiveMessageLoop">
            <summary>
            Parse, execute and send response message for all received request messages.<br/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServerSync.SendReceiveMessages">
            <summary>
            Create a send and receive queue and run a send and a receive loop. <br/>
            The loops are executed until the WebSocket is closed or disconnected. <br/>
            The method <b>don't</b> throw exception. WebSocket exceptions are catched and written to <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.Logger"/> <br/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketSyncClientHub">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> accessed remotely  using a <see cref="T:System.Net.Sockets.UdpClient"/> connection<br/>
            </summary>
            <remarks>
            Counterpart of <see cref="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpServerSync"/> used by clients.<br/>
            Implementation aligned with <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub"/>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketSyncClientHub.reqId">
            Incrementing requests id used to map a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse"/>'s to its related <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>.
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketSyncClientHub.#ctor(System.String,System.String,System.Int32,Friflo.Json.Fliox.Hub.Host.SharedEnv,Friflo.Json.Fliox.Hub.Remote.RemoteClientAccess)">
            <summary>
            if port == 0 an available port is used
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketSyncClientHub.ReceiveMessageLoop">
            <summary>
            Has no SendMessageLoop() - client send only response messages via <see cref="M:Friflo.Json.Fliox.Hub.Remote.SocketClientHub.OnReceive(Friflo.Json.Fliox.JsonValue@,Friflo.Json.Fliox.Hub.Remote.Tools.RemoteRequestMap,Friflo.Json.Fliox.Mapper.ObjectReader)"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketSyncHost">
            <summary>
            Implementation aligned with <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSocketHost"/>
            </summary>
            <remarks>
            Counterpart of <see cref="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketClientHub"/> used by the server.<br/>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpUtils.CloseSocket(System.Net.Sockets.Socket)">
            <summary>
            Close passed <paramref name="socket"/>.<br/>
            </summary>
            <remarks>
            Close also unbind a socket from the local port previously associated to with <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)"/>.<br/> 
            Includes a workaround to close a <see cref="T:System.Net.Sockets.Socket"/> using synchronous Receive() or Send() methods on macos.<br/>
            See: [UdpClient hangs when Receive is waiting and gets a Close() in macos · Issue #64551 · dotnet/runtime]
            https://github.com/dotnet/runtime/issues/64551
            </remarks>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub">
            <summary>
            A <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> accessed remotely  using a <see cref="T:System.Net.WebSockets.WebSocket"/> connection
            </summary>
            <remarks>
            Counterpart of <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSocketHost"/> used by clients.<br/>
            Implementation aligned with <see cref="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketClientHub"/>
            </remarks>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub.reqId">
            Incrementing requests id used to map a <see cref="T:Friflo.Json.Fliox.Hub.Protocol.ProtocolResponse"/>'s to its related <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>.
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub.websocketLock">
            lock (<see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub.websocketLock"/>) {
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub.#ctor(System.String,System.String,Friflo.Json.Fliox.Hub.Host.SharedEnv,Friflo.Json.Fliox.Hub.Remote.RemoteClientAccess)">
            <summary>
            Create a remote <see cref="T:Friflo.Json.Fliox.Hub.Host.FlioxHub"/> by using a <see cref="T:System.Net.WebSockets.WebSocket"/> connection
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub.ReceiveMessageLoop(Friflo.Json.Fliox.Hub.Remote.WebSocketConnection,Friflo.Json.Fliox.Mapper.ObjectReader)">
            <summary>
            Has no SendMessageLoop() - client send only response messages via <see cref="M:Friflo.Json.Fliox.Hub.Remote.SocketClientHub.OnReceive(Friflo.Json.Fliox.JsonValue@,Friflo.Json.Fliox.Hub.Remote.Tools.RemoteRequestMap,Friflo.Json.Fliox.Mapper.ObjectReader)"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSocketConnection">
            <summary>
            Store send requests in the <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSocketConnection.requestMap"/> to map received response messages to its related <see cref="T:Friflo.Json.Fliox.Hub.Protocol.SyncRequest"/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSocketHost">
            <summary>
            Implementation aligned with <see cref="T:Friflo.Json.Fliox.Hub.Remote.Transport.Udp.UdpSocketHost"/>
            </summary>
            <remarks>
            Counterpart of <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSocketClientHub"/> used by the server.<br/>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSocketHost.RunSendMessageLoop">
            <summary>
            Loop is purely I/O bound => don't wrap in
            return Task.Run(async () => { ... });
            </summary>
            <remarks>
            A send loop reading from a queue is required as message can be sent from two different sources <br/>
            1. response messages created in <see cref="M:Friflo.Json.Fliox.Hub.Remote.WebSocketHost.ReceiveMessageLoop"/> <br/>
            2. event messages send with <see cref="M:Friflo.Json.Fliox.Hub.Remote.SocketHost.SendEvent(Friflo.Json.Fliox.Hub.Host.Event.ClientEvent@)"/>'s <br/>
            The loop ensures a WebSocket.SendAsync() is called only once at a time.
            </remarks>
            <seealso cref="M:Friflo.Json.Fliox.Hub.Remote.WebSocketHost.RunReceiveMessageLoop"/>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSocketHost.SendMessageLoop">
            Send queue is required to ensure having only a single outstanding SendAsync() at any time
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSocketHost.RunReceiveMessageLoop">
            <summary>
            Loop is I/O bound and CPU bound (parse request, execute request, create response) => don't wrap in
            return Task.Run(async () => { ... });
            <br/>
            As recommended in [... Don't Use Task.Run in the Implementation] <br/>
            "They concluded that the best solution is to use an asynchronous signature
            but document the method clearly so that its CPU-bound nature will not be surprising" <br/>
            <br/>
            See. [Should I expose asynchronous wrappers for synchronous methods? - .NET Parallel Programming]
                    https://devblogs.microsoft.com/pfxteam/should-i-expose-asynchronous-wrappers-for-synchronous-methods <br/>
            See: [Task.Run Etiquette Examples: Even in the Complex Case, Don't Use Task.Run in the Implementation]
                    https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-even-in.html <br/>
            See: [Task.Run Etiquette and Proper Usage]
                    https://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSocketHost.ReceiveMessageLoop">
            <summary>
            Parse, execute and send response message for all received request messages.<br/>
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSocketHost.SendReceiveMessages(System.Net.WebSockets.WebSocket,System.Net.IPEndPoint,Friflo.Json.Fliox.Hub.Remote.HttpHost)">
            <summary>
            Create a send and receive queue and run a send and a receive loop. <br/>
            The loops are executed until the WebSocket is closed or disconnected. <br/>
            The method <b>don't</b> throw exception. WebSocket exceptions are catched and written to <see cref="P:Friflo.Json.Fliox.Hub.Host.FlioxHub.Logger"/> <br/>
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader">
            <summary>
            WebSocket stream parser implemented using a final state machine. <br/>
            Parses a WebSocket (without masking, message with length 208 bytes) stream with 2.5 GB/sec on a Intel(R) Core(TM) i7-4790K CPU 4.00GHz <br/>
            </summary>
            <remarks>
            Objectives of implementation:<br/>
            - Support <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)"/> returning only a single byte at all states<br/>
            - Maximize memory locality by using a fixed size <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.buffer"/><br/>
            - Minimize calls to <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)"/> <br/>
            - Minimize conditions. Especially in hot loops e.g. when reading the payload <see cref="M:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.ReadPayload"/><br/>
            - Minimize heap allocations. The only allocations are
            <list type="bullet">
              <item>the Task when calling <see cref="M:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.ReadFrame(System.IO.Stream,System.Byte[],System.Threading.CancellationToken)"/></item>
              <item>the Task when calling <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)"/> no more bytes left ro read in <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.buffer"/></item>
            </list>
            </remarks> 
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.buffer">
            <summary> store the bytes read from the socket.
            <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.bufferPos"/> is its read position and <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.bufferLen"/> the count of bytes read from socket</summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.frameState">
            <summary> general <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.frameState"/> and its sub states <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.payloadLenPos"/> and <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.maskingKeyPos"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.dataBufferPos">
            <summary>write position of given <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.dataBuffer"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.controlFrameBuffer">
            <summary>[RFC 6455: The WebSocket Protocol - Control Frames] https://www.rfc-editor.org/rfc/rfc6455#section-5.5.1 </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.payloadPos">
            <summary> <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.payloadPos"/> read position payload. Increments up to <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.payloadLen"/> </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.ProcessFrame">
            <summary>
            return true:  if reading payload is complete or the given <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.dataBuffer"/> is filled
            return false: if more frame bytes need to be read
            </summary>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.ReadPayload">
            <summary>
            return true:  if reading payload is complete or the given <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader.dataBuffer"/> is filled.
            return false: if more payload bytes need to be read
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolWriter">
            <summary>
            WebSocket stream writer <br/>
            Write a WebSocket stream (without masking, message with length 208 bytes) with 3.5 GB/sec on a Intel(R) Core(TM) i7-4790K CPU 4.00GHz <br/>
            </summary>
            <remarks>
            Made heap allocations only for <br/>
            - the Task when calling <see cref="M:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolWriter.WriteFrame(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.Net.WebSockets.WebSocketMessageType,System.Boolean,System.Threading.CancellationToken)"/><br/>
            </remarks>
        </member>
        <member name="M:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolWriter.CloseAsync(System.IO.Stream,System.Nullable{System.Net.WebSockets.WebSocketCloseStatus},System.String,System.Threading.CancellationToken)">
            [RFC 6455: The WebSocket Protocol - Close] https://www.rfc-editor.org/rfc/rfc6455#section-5.5.1
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameFlags">
            <summary>
            RFC 6455: The WebSocket Protocol https://www.rfc-editor.org/rfc/rfc6455#section-5.2 <br/>
            RFC 6455 in pretty: https://greenbytes.de/tech/webdav/rfc6455.html#baseframing
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.Opcode">
            <summary> RFC 6455: The WebSocket Protocol https://www.rfc-editor.org/rfc/rfc6455#section-5.2 - Opcode</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.LenFlags">
            <summary> RFC 6455: The WebSocket Protocol https://www.rfc-editor.org/rfc/rfc6455#section-5.2 - Mask</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameState">
            Basic frame states used in state machine of <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameProtocolReader"/>  
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameState.Opcode">
            <summary> <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameFlags"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameState.PayloadLenStart">
            <summary> <see cref="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.LenFlags"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameState.PayloadLen">
            <summary> encodes as 2 or 8 bytes in network byte order </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameState.Masking">
            <summary> 4 bytes used to xor the <see cref="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameState.Payload"/> </summary>
        </member>
        <member name="F:Friflo.Json.Fliox.Hub.Remote.WebSockets.FrameState.Payload">
            <summary> A frame of an application message. Either a text or binary</summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Remote.WebSockets.ServerWebSocket">
            <summary>
            A server <see cref="T:System.Net.WebSockets.WebSocket"/> implementation.<br/>
            This implementation is required for Unity as it does not provide an implementation of <c>System.Net.WebSockets.ServerWebSocket</c>.
            </summary>
        </member>
        <member name="T:Friflo.Json.Fliox.Hub.Threading.DataChannelSlim`1">
            Added <see cref="T:Friflo.Json.Fliox.Hub.Threading.DataChannelSlim`1"/> as a stub to enable compiling in Unity as there are no <see cref="T:System.Threading.Channels.Channel"/>'s
            available as of 2021-06-21.
        </member>
    </members>
</doc>
